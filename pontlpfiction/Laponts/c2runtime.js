// Generated by Construct 2, the HTML5 game and app creator :: http://www.scirra.com
var cr = {};
cr.plugins_ = {};
cr.behaviors = {};
(function(){
cr.seal = function(x)
{
if (Object.seal)
return Object.seal(x);
else
return x;
};
cr.freeze = function(x)
{
if (Object.freeze)
return Object.freeze(x);
else
return x;
};
cr.is_undefined = function (x)
{
return typeof x === "undefined";
};
cr.is_number = function (x)
{
return typeof x === "number";
};
cr.is_string = function (x)
{
return typeof x === "string";
};
cr.isPOT = function (x)
{
return x > 0 && ((x - 1) & x) === 0;
}
cr.vector2 = function (x, y)
{
this.x = x;
this.y = y;
cr.seal(this);
};
var v2Proto = cr.vector2.prototype;
v2Proto.offset = function (px, py)
{
this.x += px;
this.y += py;
return this;
};
v2Proto.mul = function (px, py)
{
this.x *= px;
this.y *= py;
return this;
};
cr.segments_intersect = function(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y)
{
if (Math.max(a1x, a2x) < Math.min(b1x, b2x)
|| Math.min(a1x, a2x) > Math.max(b1x, b2x)
|| Math.max(a1y, a2y) < Math.min(b1y, b2y)
|| Math.min(a1y, a2y) > Math.max(b1y, b2y))
{
return false;
}
var dpx = b1x - a1x + b2x - a2x;
var dpy = b1y - a1y + b2y - a2y;
var qax = a2x - a1x;
var qay = a2y - a1y;
var qbx = b2x - b1x;
var qby = b2y - b1y;
var d = Math.abs(qay * qbx - qby * qax);
var la = qbx * dpy - qby * dpx;
var lb = qax * dpy - qay * dpx;
return Math.abs(la) <= d && Math.abs(lb) <= d;
};
cr.rect = function (left, top, right, bottom)
{
this.set(left, top, right, bottom);
cr.seal(this);
};
var rectProto = cr.rect.prototype;
rectProto.set = function (left, top, right, bottom)
{
this.left = left;
this.top = top;
this.right = right;
this.bottom = bottom;
};
rectProto.width = function ()
{
return this.right - this.left;
};
rectProto.height = function ()
{
return this.bottom - this.top;
};
rectProto.offset = function (px, py)
{
this.left += px;
this.top += py;
this.right += px;
this.bottom += py;
return this;
};
rectProto.intersects_rect = function (rc)
{
return !(rc.right < this.left || rc.bottom < this.top || rc.left > this.right || rc.top > this.bottom);
};
rectProto.contains_pt = function (x, y)
{
return (x >= this.left && x <= this.right) && (y >= this.top && y <= this.bottom);
};
cr.quad = function ()
{
this.tlx = 0;
this.tly = 0;
this.trx = 0;
this.try_ = 0;	// is a keyword otherwise!
this.brx = 0;
this.bry = 0;
this.blx = 0;
this.bly = 0;
cr.seal(this);
};
var quadProto = cr.quad.prototype;
quadProto.set_from_rect = function (rc)
{
this.tlx = rc.left;
this.tly = rc.top;
this.trx = rc.right;
this.try_ = rc.top;
this.brx = rc.right;
this.bry = rc.bottom;
this.blx = rc.left;
this.bly = rc.bottom;
};
quadProto.set_from_rotated_rect = function (rc, a)
{
if (a === 0)
{
this.set_from_rect(rc);
}
else
{
var sin_a = Math.sin(a);
var cos_a = Math.cos(a);
var left_sin_a = rc.left * sin_a;
var top_sin_a = rc.top * sin_a;
var right_sin_a = rc.right * sin_a;
var bottom_sin_a = rc.bottom * sin_a;
var left_cos_a = rc.left * cos_a;
var top_cos_a = rc.top * cos_a;
var right_cos_a = rc.right * cos_a;
var bottom_cos_a = rc.bottom * cos_a;
this.tlx = left_cos_a - top_sin_a;
this.tly = top_cos_a + left_sin_a;
this.trx = right_cos_a - top_sin_a;
this.try_ = top_cos_a + right_sin_a;
this.brx = right_cos_a - bottom_sin_a;
this.bry = bottom_cos_a + right_sin_a;
this.blx = left_cos_a - bottom_sin_a;
this.bly = bottom_cos_a + left_sin_a;
}
};
quadProto.offset = function (px, py)
{
this.tlx += px;
this.tly += py;
this.trx += px;
this.try_ += py;
this.brx += px;
this.bry += py;
this.blx += px;
this.bly += py;
return this;
};
quadProto.bounding_box = function (rc)
{
rc.left =   Math.min(this.tlx, this.trx,  this.brx, this.blx);
rc.top =    Math.min(this.tly, this.try_, this.bry, this.bly);
rc.right =  Math.max(this.tlx, this.trx,  this.brx, this.blx);
rc.bottom = Math.max(this.tly, this.try_, this.bry, this.bly);
};
quadProto.contains_pt = function (x, y)
{
var v0x = this.trx - this.tlx;
var v0y = this.try_ - this.tly;
var v1x = this.brx - this.tlx;
var v1y = this.bry - this.tly;
var v2x = x - this.tlx;
var v2y = y - this.tly;
var dot00 = v0x * v0x + v0y * v0y
var dot01 = v0x * v1x + v0y * v1y
var dot02 = v0x * v2x + v0y * v2y
var dot11 = v1x * v1x + v1y * v1y
var dot12 = v1x * v2x + v1y * v2y
var invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);
var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
if ((u >= 0.0) && (v > 0.0) && (u + v < 1))
return true;
v0x = this.blx - this.tlx;
v0y = this.bly - this.tly;
var dot00 = v0x * v0x + v0y * v0y
var dot01 = v0x * v1x + v0y * v1y
var dot02 = v0x * v2x + v0y * v2y
invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);
u = (dot11 * dot02 - dot01 * dot12) * invDenom;
v = (dot00 * dot12 - dot01 * dot02) * invDenom;
return (u >= 0.0) && (v > 0.0) && (u + v < 1);
};
quadProto.at = function (i, xory)
{
i = i % 4;
if (i < 0)
i += 4;
switch (i)
{
case 0: return xory ? this.tlx : this.tly;
case 1: return xory ? this.trx : this.try_;
case 2: return xory ? this.brx : this.bry;
case 3: return xory ? this.blx : this.bly;
default: return xory ? this.tlx : this.tly;
}
};
quadProto.midX = function ()
{
return (this.tlx + this.trx  + this.brx + this.blx) / 4;
};
quadProto.midY = function ()
{
return (this.tly + this.try_ + this.bry + this.bly) / 4;
};
quadProto.intersects_quad = function (rhs)
{
var midx = rhs.midX();
var midy = rhs.midY();
if (this.contains_pt(midx, midy))
return true;
midx = this.midX();
midy = this.midY();
if (rhs.contains_pt(midx, midy))
return true;
var a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y;
var i, j;
for (i = 0; i < 4; i++)
{
for (j = 0; j < 4; j++)
{
a1x = this.at(i, true);
a1y = this.at(i, false);
a2x = this.at(i + 1, true);
a2y = this.at(i + 1, false);
b1x = rhs.at(j, true);
b1y = rhs.at(j, false);
b2x = rhs.at(j + 1, true);
b2y = rhs.at(j + 1, false);
if (cr.segments_intersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y))
return true;
}
}
return false;
};
cr.RGB = function (red, green, blue)
{
return Math.max(Math.min(red, 255), 0)
| (Math.max(Math.min(green, 255), 0) << 8)
| (Math.max(Math.min(blue, 255), 0) << 16);
};
cr.shallowCopy = function (a, b, allowOverwrite)
{
var attr;
for (attr in b)
{
if (b.hasOwnProperty(attr))
{
;
a[attr] = b[attr];
}
}
};
cr.arrayRemove = function (arr, index)
{
var sliced;
if (index < 1)
arr.shift();
else
{
sliced = arr.slice(index + 1);
arr.length = index;
arr.push.apply(arr, sliced);
}
};
cr.arrayFindRemove = function (arr, item)
{
var index = jQuery.inArray(item, arr);
if (index >= 0)
cr.arrayRemove(arr, index);
};
cr.clamp = function(x, a, b)
{
if (x < a)
return a;
else if (x > b)
return b;
else
return x;
};
cr.to_radians = function(x)
{
return x / (180.0 / Math.PI);
};
cr.to_degrees = function(x)
{
return x * (180.0 / Math.PI);
};
cr.clamp_angle_degrees = function (a)
{
var angle = a;
angle %= 360;       // now in (-360, 360) range
if (angle < 0)
angle += 360;   // now in [0, 360) range
return angle;
};
cr.clamp_angle = function (a)
{
var angle = a;
angle %= 2 * Math.PI;       // now in (-2pi, 2pi) range
if (angle < 0)
angle += 2 * Math.PI;   // now in [0, 2pi) range
return angle;
};
cr.to_clamped_degrees = function (x)
{
return cr.clamp_angle_degrees(cr.to_degrees(x));
};
cr.to_clamped_radians = function (x)
{
return cr.clamp_angle(cr.to_radians(x));
};
cr.angleTo = function(x1, y1, x2, y2)
{
var dx = x2 - x1;
var dy = y2 - y1;
return Math.atan2(dy, dx);
};
cr.angleDiff = function (a1, a2)
{
if (a1 === a2)
return 0;
var s1 = Math.sin(a1);
var c1 = Math.cos(a1);
var s2 = Math.sin(a2);
var c2 = Math.cos(a2);
var n = s1 * s2 + c1 * c2;
if (n >= 1)
return 0;
if (n <= -1)
return Math.PI;
return Math.acos(n);
};
cr.angleRotate = function (start, end, step)
{
var ss = Math.sin(start);
var cs = Math.cos(start);
var se = Math.sin(end);
var ce = Math.cos(end);
if (Math.acos(ss * se + cs * ce) > step)
{
if (cs * se - ss * ce > 0)
return cr.clamp_angle(start + step);
else
return cr.clamp_angle(start - step);
}
else
return cr.clamp_angle(end);
};
cr.angleClockwise = function (a1, a2)
{
var s1 = Math.sin(a1);
var c1 = Math.cos(a1);
var s2 = Math.sin(a2);
var c2 = Math.cos(a2);
return c1 * s2 - s1 * c2 <= 0;
};
cr.distanceTo = function(x1, y1, x2, y2)
{
var dx = x2 - x1;
var dy = y2 - y1;
return Math.sqrt(dx*dx + dy*dy);
};
cr.xor = function (x, y)
{
return !x !== !y;
};
cr.lerp = function (a, b, x)
{
return a + (b - a) * x;
};
cr.ObjectSet = function ()
{
this.items = {};
this.item_count = 0;
this.values_cache = [];
this.cache_valid = true;
cr.seal(this);
};
var ObjectSetProto = cr.ObjectSet.prototype;
ObjectSetProto.contains = function (x)
{
return this.items.hasOwnProperty(x.toString());
};
ObjectSetProto.add = function (x)
{
if (!this.contains(x))
{
this.items[x.toString()] = x;
this.item_count++;
this.cache_valid = false;
}
return this;
};
ObjectSetProto.remove = function (x)
{
if (this.contains(x))
{
delete this.items[x.toString()];
this.item_count--;
this.cache_valid = false;
}
return this;
};
ObjectSetProto.clear = function ()
{
this.items = {};
this.item_count = 0;
this.values_cache.length = 0;
this.cache_valid = true;
return this;
};
ObjectSetProto.isEmpty = function ()
{
return this.item_count === 0;
};
ObjectSetProto.count = function ()
{
return this.item_count;
};
ObjectSetProto.update_cache = function ()
{
if (this.cache_valid)
return;
this.values_cache.length = 0;
var i;
for (i in this.items)
{
if (this.items.hasOwnProperty(i))
this.values_cache.push(this.items[i]);
}
this.cache_valid = true;
};
ObjectSetProto.values = function ()
{
this.update_cache();
return this.values_cache.slice(0);
};
ObjectSetProto.valuesRef = function ()
{
this.update_cache();
return this.values_cache;
};
cr.KahanAdder = function ()
{
this.c = 0;
this.y = 0;
this.t = 0;
this.sum = 0;
cr.seal(this);
};
var KahanProto = cr.KahanAdder.prototype;
KahanProto.add = function (v)
{
this.y = v - this.c;
this.t = this.sum + this.y;
this.c = (this.t - this.sum) - this.y;
this.sum = this.t;
};
KahanProto.reset = function ()
{
this.c = 0;
this.y = 0;
this.t = 0;
this.sum = 0;
};
cr.regexp_escape = function(text)
{
return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
};
cr.CollisionPoly = function (pts_array_)
{
this.pts_cache = [];
this.set_pts(pts_array_);
cr.seal(this);
};
var CollisionPolyProto = cr.CollisionPoly.prototype;
CollisionPolyProto.set_pts = function(pts_array_)
{
this.pts_array = pts_array_;
this.pts_count = pts_array_.length / 2;			// x, y, x, y... in array
this.pts_cache.length = pts_array_.length;
this.cache_width = -1;
this.cache_height = -1;
this.cache_angle = 0;
};
CollisionPolyProto.is_empty = function()
{
return !this.pts_array.length;
};
CollisionPolyProto.set_from_quad = function(q, offx, offy, w, h)
{
this.pts_cache.length = 8;
this.pts_count = 4;
this.pts_cache[0] = q.tlx - offx;
this.pts_cache[1] = q.tly - offy;
this.pts_cache[2] = q.trx - offx;
this.pts_cache[3] = q.try_ - offy;
this.pts_cache[4] = q.brx - offx;
this.pts_cache[5] = q.bry - offy;
this.pts_cache[6] = q.blx - offx;
this.pts_cache[7] = q.bly - offy;
this.cache_width = w;
this.cache_height = h;
};
CollisionPolyProto.cache_poly = function(w, h, a)
{
if (this.cache_width === w && this.cache_height === h && this.cache_angle === a)
return;		// cache up-to-date
this.cache_width = w;
this.cache_height = h;
this.cache_angle = a;
var i, len, x, y, x_temp;
var sina = 0;
var cosa = 1;
if (a !== 0)
{
sina = Math.sin(a);
cosa = Math.cos(a);
}
for (i = 0, len = this.pts_count; i < len; i++)
{
x = this.pts_array[i*2] * w;
y = this.pts_array[i*2+1] * h;
this.pts_cache[i*2] = (x * cosa) - (y * sina);
this.pts_cache[i*2+1] = (y * cosa) + (x * sina);
}
};
CollisionPolyProto.contains_pt = function (a2x, a2y)
{
if (a2x === this.pts_cache[0] && a2y === this.pts_cache[1])
return true;
var a1x = -this.cache_width * 5 - 1;
var a1y = -this.cache_height * 5 - 1;
var a3x = this.cache_width * 5 + 1;
var a3y = -1;
var b1x, b1y, b2x, b2y;
var i, len;
var count1 = 0, count2 = 0;
for (i = 0, len = this.pts_count; i < len; i++)
{
b1x = this.pts_cache[i*2];
b1y = this.pts_cache[i*2+1];
b2x = this.pts_cache[((i+1)%len)*2];
b2y = this.pts_cache[((i+1)%len)*2+1];
if (cr.segments_intersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y))
count1++;
if (cr.segments_intersect(a3x, a3y, a2x, a2y, b1x, b1y, b2x, b2y))
count2++;
}
return (count1 % 2 === 1) || (count2 % 2 === 1);
};
CollisionPolyProto.intersects_poly = function (rhs, offx, offy)
{
if (this.contains_pt(rhs.pts_cache[0] + offx, rhs.pts_cache[1] + offy))
return true;
if (rhs.contains_pt(this.pts_cache[0] - offx, this.pts_cache[1] - offy))
return true;
var i, leni, j, lenj;
var a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y;
for (i = 0, leni = this.pts_count; i < leni; i++)
{
a1x = this.pts_cache[i*2];
a1y = this.pts_cache[i*2+1];
a2x = this.pts_cache[((i+1)%leni)*2];
a2y = this.pts_cache[((i+1)%leni)*2+1];
for (j = 0, lenj = rhs.pts_count; j < lenj; j++)
{
b1x = rhs.pts_cache[j*2] + offx;
b1y = rhs.pts_cache[j*2+1] + offy;
b2x = rhs.pts_cache[((j+1)%lenj)*2] + offx;
b2y = rhs.pts_cache[((j+1)%lenj)*2+1] + offy;
if (cr.segments_intersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y))
return true;
}
}
return false;
};
}());
;
(function()
{
cr.createRuntime = function (canvasid)
{
return new cr.runtime(document.getElementById(canvasid));
};
cr.runtime = function (canvas)
{
if (!canvas || !canvas.getContext)
return;
this.isPhoneGap = (typeof window["device"] !== "undefined" && typeof window["device"]["phonegap"] !== "undefined");
if (typeof cr_is_preview === "undefined" && window.location.protocol.substr(0, 4) === "file" && !this.isPhoneGap)
{
alert("Note: browsers have very strict security limitations on pages viewed from disk.  This means exported projects generally don't work when run from disk.  Upload your project to a server, or just preview from inside Construct 2, to check it works.");
}
this.canvas = canvas;
this.gl = null;
this.glwrap = null;
this.ctx = null;
canvas["c2runtime"] = this;
this.width = canvas.width;
this.height = canvas.height;
this.redraw = true;
if (!Date.now) {
Date.now = function now() {
return +new Date();
};
}
this.plugins = [];
this.types = {};
this.types_by_index = [];
this.behaviors = [];
this.layouts = {};
this.layouts_by_index = [];
this.eventsheets = {};
this.eventsheets_by_index = [];
this.wait_for_textures = [];        // for blocking until textures loaded
this.triggers_to_postinit = [];
this.all_global_vars = [];
this.deathRow = new cr.ObjectSet();
this.dt = 0;                
this.dt1 = 0;
this.zeroDtCount = 0;
this.timescale = 1.0;
this.kahanTime = new cr.KahanAdder();
this.last_tick_time = 0;
this.measuring_dt = true;
this.fps = 0;
this.last_fps_time = 0;
this.tickcount = 0;
this.execcount = 0;
this.framecount = 0;        // for fps
this.objectcount = 0;
this.changelayout = null;
this.destroycallbacks = [];
this.event_stack = [];
this.event_stack_index = -1;
this.pushEventStack(null);
this.loop_stack = [];
this.loop_stack_index = -1;
this.next_uid = 0;
this.layout_first_tick = true;
this.objects_to_tick = new cr.ObjectSet();
this.registered_collisions = [];
this.temp_poly = new cr.CollisionPoly([]);
this.activeGroups = {};				// event group activation state
this.running_layout = null;			// currently running layout
this.layer_canvas = null;			// for layers "render-to-texture"
this.layer_ctx = null;
this.layer_tex = null;
this.files_subfolder = "";			// path with project files
this.html5logo = new Image();
this.html5logo.src = "logo.png";	// only 1kb!
this.load();
try {
if (this.enableWebGL)
{
var attribs = { "depth": false };
this.gl = (canvas.getContext("webgl", attribs) || canvas.getContext("experimental-webgl", attribs)
|| canvas.getContext("webkit-3d", attribs) || canvas.getContext("moz-webgl", attribs));
}
}
catch (e) {
}
if (this.gl)
{
;
this.overlay_canvas = document.createElement("canvas");
jQuery(this.overlay_canvas).appendTo("body");
this.overlay_canvas.width = canvas.width;
this.overlay_canvas.height = canvas.height;
jQuery(this.overlay_canvas).offset(jQuery(canvas).offset());
this.overlay_ctx = this.overlay_canvas.getContext("2d");
this.glwrap = new cr.GLWrap(this.gl);
this.glwrap.setSize(canvas.width, canvas.height);
this.ctx = null;
}
else
{
;
this.ctx = canvas.getContext("2d");
this.overlay_canvas = null;
this.overlay_ctx = null;
}
this.go();
this.extra = {};
cr.seal(this);
};
var runtimeProto = cr.runtime.prototype;
runtimeProto["setSize"] = function (w, h)
{
this.width = w;
this.height = h;
this.redraw = true;
if (this.overlay_canvas)
{
this.overlay_canvas.width = w;
this.overlay_canvas.height = h;
}
if (this.glwrap)
this.glwrap.setSize(w, h);
};
runtimeProto.load = function ()
{
;
var pm = cr.getProjectModel();
this.name = pm[0];
this.first_layout = pm[1];
this.system = new cr.system_object(this);
var i, len, j, lenj, k, lenk, idstr, m, b;
var plugin, plugin_ctor;
for (i = 0, len = pm[2].length; i < len; i++)
{
m = pm[2][i];
;
cr.add_common_aces(m);
plugin = new m[0](this);
plugin.singleglobal = m[1];
plugin.is_world = m[2];
if (plugin.onCreate)
plugin.onCreate();  // opportunity to override default ACEs
cr.seal(plugin);
this.plugins.push(plugin);
}
pm = cr.getProjectModel();
for (i = 0, len = pm[3].length; i < len; i++)
{
m = pm[3][i];
plugin_ctor = m[1];
;
plugin = null;
for (j = 0, lenj = this.plugins.length; j < lenj; j++)
{
if (this.plugins[j] instanceof plugin_ctor)
{
plugin = this.plugins[j];
break;
}
}
;
;
var type_inst = new plugin.Type(plugin);
;
type_inst.name = m[0];
if (m[2])
{
type_inst.texture_file = m[2][0];
type_inst.texture_filesize = m[2][1];
}
if (m[3])
{
type_inst.animations = m[3];
}
type_inst.index = i;                                // save index in to types array in type
type_inst.instances = [];                           // all instances of this type
type_inst.deadCache = [];							// destroyed instances to recycle next create
type_inst.solstack = [new cr.selection(type_inst)]; // initialise SOL stack with one empty SOL
type_inst.cur_sol = 0;
type_inst.default_instance = null;
type_inst.stale_iids = true;
type_inst.updateIIDs = cr.type_updateIIDs;
type_inst.getFirstPicked = cr.type_getFirstPicked;
type_inst.getPairedInstance = cr.type_getPairedInstance;
type_inst.getCurrentSol = cr.type_getCurrentSol;
type_inst.pushCleanSol = cr.type_pushCleanSol;
type_inst.pushCopySol = cr.type_pushCopySol;
type_inst.popSol = cr.type_popSol;
type_inst.getBehaviorByName = cr.type_getBehaviorByName;
type_inst.getBehaviorIndexByName = cr.type_getBehaviorIndexByName;
type_inst.behaviors = [];
for (j = 0, lenj = m[4].length; j < lenj; j++)
{
b = m[4][j];
var behavior_ctor = b[1];
var behavior_plugin = null;
for (k = 0, lenk = this.behaviors.length; k < lenk; k++)
{
if (this.behaviors[k] instanceof behavior_ctor)
{
behavior_plugin = this.behaviors[k];
break;
}
}
if (!behavior_plugin)
{
behavior_plugin = new behavior_ctor(this);
behavior_plugin.my_instances = new cr.ObjectSet(); 	// instances of this behavior
if (behavior_plugin.onCreate)
behavior_plugin.onCreate();
cr.seal(behavior_plugin);
this.behaviors.push(behavior_plugin);
}
var behavior_type = new behavior_plugin.Type(behavior_plugin, type_inst);
behavior_type.name = b[0];
behavior_type.onCreate();
cr.seal(behavior_type);
type_inst.behaviors.push(behavior_type);
}
type_inst.global = m[5];
type_inst.onCreate();
cr.seal(type_inst);
if (type_inst.name)
this.types[type_inst.name] = type_inst;
this.types_by_index.push(type_inst);
if (plugin.singleglobal)
{
var instance = new plugin.Instance(type_inst);
instance.uid = this.next_uid;
this.next_uid++;
instance.iid = 0;
instance.get_iid = cr.inst_get_iid;
instance.toString = cr.inst_toString;
instance.properties = m[6];
instance.onCreate();
cr.seal(instance);
type_inst.instances.push(instance);
}
}
for (i = 0, len = pm[4].length; i < len; i++)
{
m = pm[4][i];
var layout = new cr.layout(this, m);
cr.seal(layout);
this.layouts[layout.name] = layout;
this.layouts_by_index.push(layout);
}
for (i = 0, len = pm[5].length; i < len; i++)
{
m = pm[5][i];
var sheet = new cr.eventsheet(this, m);
cr.seal(sheet);
this.eventsheets[sheet.name] = sheet;
this.eventsheets_by_index.push(sheet);
}
for (i = 0, len = this.eventsheets_by_index.length; i < len; i++)
this.eventsheets_by_index[i].postInit();
for (i = 0, len = this.triggers_to_postinit.length; i < len; i++)
this.triggers_to_postinit[i].postInit();
delete this.triggers_to_postinit;
this.files_subfolder = pm[6];
this.pixel_rounding = pm[7];
this.original_width = pm[8];
this.original_height = pm[9];
this.aspect_scale = 1.0;
this.scale_fullscreen = pm[10];
this.enableWebGL = pm[11];
this.linearSampling = pm[12];
this.start_time = Date.now();
};
runtimeProto.areAllTexturesLoaded = function ()
{
var totalsize = 0;
var completedsize = 0;
var ret = true;
var i, len;
for (i = 0, len = this.wait_for_textures.length; i < len; i++)
{
var filesize = this.wait_for_textures[i].cr_filesize;
if (!filesize || filesize <= 0)
filesize = 50000;
totalsize += filesize;
if (this.wait_for_textures[i].complete)
completedsize += filesize;
else
ret = false;    // not all textures loaded
}
if (totalsize == 0)
this.progress = 0;
else
this.progress = (completedsize / totalsize);
return ret;
};
runtimeProto.go = function ()
{
if (!this.ctx && !this.gl)
return;
var ctx = this.ctx || this.overlay_ctx;
this.progress = 0;
this.last_progress = -1;
if (this.areAllTexturesLoaded())
this.go_textures_done();
else
{
var ms_elapsed = Date.now() - this.start_time;
if ((ms_elapsed >= 500 && this.html5logo.complete) && this.last_progress != this.progress)
{
ctx.clearRect(0, 0, this.width, this.height);
var mx = this.width / 2;
var my = this.height / 2;
var hlw = this.html5logo.width / 2;
var hlh = this.html5logo.height / 2;
ctx.drawImage(this.html5logo, Math.floor(mx - hlw), Math.floor(my - hlh));
my += hlh + 12;
mx -= hlw;
mx = Math.floor(mx) + 0.5;
my = Math.floor(my) + 0.5;
ctx.fillStyle = "DodgerBlue";
ctx.fillRect(mx, my, Math.floor(this.html5logo.width * this.progress), 6);
ctx.strokeStyle = "black";
ctx.strokeRect(mx, my, this.html5logo.width, 6);
ctx.strokeStyle = "white";
ctx.strokeRect(mx - 1, my - 1, this.html5logo.width + 2, 8);
this.last_progress = this.progress;
}
setTimeout((function (self) { return function () { self.go(); }; })(this), 100);
}
};
runtimeProto.go_textures_done = function ()
{
var i, len;
for (i = 0, len = this.layouts_by_index.length; i < len; i++)
{
this.layouts_by_index[i].createGlobalNonWorlds();
}
if (this.first_layout)
this.layouts[this.first_layout].startRunning();
else
this.layouts_by_index[0].startRunning();
;
this.start_time = Date.now();
this.last_fps_time = this.start_time;       // for counting framerate
this.tick();
};
var raf = window.requestAnimationFrame ||
window.mozRequestAnimationFrame    ||
window.webkitRequestAnimationFrame ||
window.msRequestAnimationFrame     ||
window.oRequestAnimationFrame;
runtimeProto.tick = function ()
{
;
if (this.overlay_canvas)
jQuery(this.overlay_canvas).offset(jQuery(this.canvas).offset());
this.logic();
if (this.redraw && !document.hidden)
{
if (this.gl)
this.drawGL();
else
this.draw();
this.redraw = false;
}
this.tickcount++;
this.execcount++;
this.framecount++;
if (raf)
raf((function (self) { return function () { self.tick(); }; })(this), this.canvas);
else
setTimeout((function (self) { return function () { self.tick(); }; })(this), 16);
};
runtimeProto.logic = function ()
{
var i, leni, j, lenj, k, lenk, type, binst;
var cur_time = Date.now();
if (cur_time - this.last_fps_time >= 1000)  // every 1 second
{
this.last_fps_time += 1000;
this.fps = this.framecount;
this.framecount = 0;
}
if (this.measuring_dt)
{
if (this.last_tick_time !== 0)
{
var ms_diff = cur_time - this.last_tick_time;
if (ms_diff === 0)
{
this.zeroDtCount++;
if (this.zeroDtCout >= 10)
this.measuring_dt = false;
this.dt1 = 1.0 / 60.0;            // 60fps assumed (0.01666...)
;
}
else
{
this.dt1 = ms_diff / 1000.0; // dt measured in seconds
if (this.dt1 > 0.5 || document.hidden)
this.dt1 = 0;
else if (this.dt1 > 0.1)
this.dt1 = 0.1;
}
}
this.last_tick_time = cur_time;
}
this.dt = this.dt1 * this.timescale;
this.kahanTime.add(this.dt);
if (this.scale_fullscreen)
{
var orig_aspect = this.original_width / this.original_height;
var cur_aspect = this.width / this.height;
if (cur_aspect > orig_aspect)
this.aspect_scale = this.height / this.original_height;
else
{
this.aspect_scale = this.width / this.original_width;
}
if (this.running_layout)
{
this.running_layout.scrollToX(this.running_layout.scrollX);
this.running_layout.scrollToY(this.running_layout.scrollY);
}
}
this.ClearDeathRow();
this.system.runWaits();
if (this.changelayout)
{
;
this.running_layout.stopRunning();
this.changelayout.startRunning();
for (i = 0, leni = this.types_by_index.length; i < leni; i++)
{
type = this.types_by_index[i];
if (!type.global && !type.plugin.singleglobal)
continue;
for (j = 0, lenj = type.instances.length; j < lenj; j++)
{
var inst = type.instances[j];
if (inst.onLayoutChange)
inst.onLayoutChange();
}
}
this.changelayout = null;
this.redraw = true;
this.layout_first_tick = true;
}
for (i = 0, leni = this.types_by_index.length; i < leni; i++)
{
type = this.types_by_index[i];
if (!type.behaviors.length)
continue;	// type doesn't have any behaviors
for (j = 0, lenj = type.instances.length; j < lenj; j++)
{
var inst = type.instances[j];
for (k = 0, lenk = inst.behavior_insts.length; k < lenk; k++)
{
inst.behavior_insts[k].tick();
}
}
}
var tickarr = this.objects_to_tick.valuesRef();
for (i = 0, leni = tickarr.length; i < leni; i++)
tickarr[i].tick();
for (i = 0, leni = this.eventsheets_by_index.length; i < leni; i++)
this.eventsheets_by_index[i].hasRun = false;
if (this.running_layout.event_sheet)
this.running_layout.event_sheet.run();
this.registered_collisions.length = 0;
this.layout_first_tick = false;
for (i = 0, leni = this.types_by_index.length; i < leni; i++)
{
type = this.types_by_index[i];
if (!type.behaviors.length)
continue;	// type doesn't have any behaviors
for (j = 0, lenj = type.instances.length; j < lenj; j++)
{
var inst = type.instances[j];
for (k = 0, lenk = inst.behavior_insts.length; k < lenk; k++)
{
binst = inst.behavior_insts[k];
if (binst.tick2)
binst.tick2();
}
}
}
};
runtimeProto.tickMe = function (inst)
{
this.objects_to_tick.add(inst);
};
runtimeProto.getDt = function (inst)
{
if (!inst || inst.my_timescale === -1.0)
return this.dt;
return this.dt1 * inst.my_timescale;
};
runtimeProto.draw = function ()
{
this.running_layout.draw(this.ctx);
};
runtimeProto.drawGL = function ()
{
this.overlay_ctx.clearRect(0, 0, this.width, this.height);
this.running_layout.drawGL(this.glwrap);
};
runtimeProto.addDestroyCallback = function (f)
{
if (f)
this.destroycallbacks.push(f);
};
runtimeProto.DestroyInstance = function (inst)
{
this.deathRow.add(inst);
};
runtimeProto.ClearDeathRow = function ()
{
var inst, index, type, instances, binst;
var i, j, leni, lenj;
var w;
var arr = this.deathRow.valuesRef();	// get array of items from set
for (i = 0, leni = arr.length; i < leni; i++)
{
inst = arr[i];
type = inst.type;
instances = type.instances;
for (j = 0, lenj = this.destroycallbacks.length; j < lenj; j++)
this.destroycallbacks[j](inst);
cr.arrayFindRemove(instances, inst);
if (inst.layer)
{
cr.arrayRemove(inst.layer.instances, inst.get_zindex());
inst.layer.zindices_stale = true;
}
if (inst.behavior_insts)
{
for (j = 0, lenj = inst.behavior_insts.length; j < lenj; j++)
{
binst = inst.behavior_insts[j];
if (binst.onDestroy)
binst.onDestroy();
binst.behavior.my_instances.remove(inst);
}
}
this.objects_to_tick.remove(inst);
for (j = 0, lenj = this.system.waits.length; j < lenj; j++)
{
w = this.system.waits[j];
if (!w.sols.hasOwnProperty(type.index))
continue;
cr.arrayFindRemove(w.sols[type.index], inst);
}
if (inst.onDestroy)
inst.onDestroy();
this.objectcount--;
if (type.deadCache.length < 32)
type.deadCache.push(inst);
}
if (!this.deathRow.isEmpty())
this.redraw = true;
this.deathRow.clear();
};
runtimeProto.createInstance = function (type, layer, sx, sy)
{
return this.createInstanceFromInit(type.default_instance, layer, false, sx, sy);
};
runtimeProto.createInstanceFromInit = function (initial_inst, layer, is_startup_instance, sx, sy)
{
var i, len, j, lenj, p;
;
var type = this.types_by_index[initial_inst[1]];
;
var is_world = type.plugin.is_world;
;
var inst;
var recycled_inst = false;
if (type.deadCache.length)
{
inst = type.deadCache.pop();
recycled_inst = true;
type.plugin.Instance.call(inst, type);
}
else
inst = new type.plugin.Instance(type);
inst.uid = this.next_uid;
this.next_uid++;
inst.iid = 0;
inst.get_iid = cr.inst_get_iid;
type.stale_iids = true;
var initial_vars = initial_inst[2];
if (recycled_inst)
{
for (i = 0, len = initial_vars.length; i < len; i++)
inst.instance_vars[i] = initial_vars[i];
for (p in inst.extra)
{
if (inst.extra.hasOwnProperty(p))
delete inst.extra[p];
}
}
else
{
inst.instance_vars = initial_vars.slice(0);
inst.extra = {};
}
if (is_world)
{
var wm = initial_inst[0];
;
inst.x = cr.is_undefined(sx) ? wm[0] : sx;
inst.y = cr.is_undefined(sy) ? wm[1] : sy;
inst.z = wm[2];
inst.width = wm[3];
inst.height = wm[4];
inst.depth = wm[5];
inst.angle = wm[6];
inst.opacity = wm[7];
inst.hotspotX = wm[8];
inst.hotspotY = wm[9];
if (recycled_inst)
{
inst.bbox.set(0, 0, 0, 0);
inst.bquad.set_from_rect(inst.bbox);
inst.bbox_changed_callbacks.length = 0;
}
else
{
inst.bbox = new cr.rect(0, 0, 0, 0);
inst.bquad = new cr.quad();
inst.bbox_changed_callbacks = [];
inst.set_bbox_changed = cr.set_bbox_changed;
inst.add_bbox_changed_callback = cr.add_bbox_changed_callback;
inst.contains_pt = cr.inst_contains_pt;
inst.update_bbox = cr.update_bbox;
inst.get_zindex = cr.inst_get_zindex;
}
inst.bbox_changed = true;
inst.visible = true;
inst.my_timescale = -1.0;
inst.layer = layer;
inst.zindex = layer.instances.length;	// will be placed at top of current layer
this.redraw = true;
}
inst.toString = cr.inst_toString;
var initial_props, binst;
if (recycled_inst)
{
for (i = 0, len = type.behaviors.length; i < len; i++)
{
var btype = type.behaviors[i];
binst = inst.behavior_insts[i];
btype.behavior.Instance.call(binst, btype, inst);
initial_props = initial_inst[3][i];
for (j = 0, lenj = initial_props.length; j < lenj; j++)
binst.properties[j] = initial_props[j];
binst.onCreate();
btype.behavior.my_instances.add(inst);
}
}
else
{
inst.behavior_insts = [];
for (i = 0, len = type.behaviors.length; i < len; i++)
{
var btype = type.behaviors[i];
var binst = new btype.behavior.Instance(btype, inst);
binst.properties = initial_inst[3][i].slice(0);
binst.onCreate();
cr.seal(binst);
inst.behavior_insts.push(binst);
btype.behavior.my_instances.add(inst);
}
}
initial_props = initial_inst[4];
if (recycled_inst)
{
for (i = 0, len = initial_props.length; i < len; i++)
inst.properties[i] = initial_props[i];
}
else
inst.properties = initial_props.slice(0);
type.instances.push(inst);
if (layer)
layer.instances.push(inst);
this.objectcount++;
inst.onCreate();
if (!recycled_inst)
cr.seal(inst);
return inst;
};
runtimeProto.getLayerByName = function (layer_name)
{
var i, len;
for (i = 0, len = this.running_layout.layers.length; i < len; i++)
{
var layer = this.running_layout.layers[i];
if (layer.name === layer_name)
return layer;
}
return null;
};
runtimeProto.getLayerByNumber = function (index)
{
index = Math.floor(index);
if (index < 0)
index = 0;
if (index >= this.running_layout.layers.length)
index = this.running_layout.layers.length - 1;
return this.running_layout.layers[index];
};
runtimeProto.getLayer = function (l)
{
if (cr.is_number(l))
return this.getLayerByNumber(l);
else
return this.getLayerByName(l.toString());
};
cr.layout = function (runtime, m)
{
this.runtime = runtime;
this.event_sheet = null;
this.scrollX = (this.runtime.original_width / 2);
this.scrollY = (this.runtime.original_height / 2);
this.scale = 1.0;
this.angle = 0;
this.name = m[0];
this.width = m[1];
this.height = m[2];
this.unbounded_scrolling = m[3];
this.sheetname = m[4];
var lm = m[5];
var i, len;
this.layers = [];
for (i = 0, len = lm.length; i < len; i++)
{
var layer = new cr.layer(this, lm[i]);
layer.number = i;
cr.seal(layer);
this.layers.push(layer);
}
var im = m[6];
this.initial_nonworld = [];
for (i = 0, len = im.length; i < len; i++)
{
var inst = im[i];
var type = this.runtime.types_by_index[inst[1]];
;
if (!type.default_instance)
type.default_instance = inst;
this.initial_nonworld.push(inst);
}
};
var layoutProto = cr.layout.prototype;
layoutProto.startRunning = function ()
{
if (this.sheetname)
{
this.event_sheet = this.runtime.eventsheets[this.sheetname];
;
}
this.runtime.running_layout = this;
this.scrollX = (this.runtime.original_width / 2);
this.scrollY = (this.runtime.original_height / 2);
var i, k, len, lenk, type_instances, inst;
for (i = 0, len = this.runtime.types_by_index.length; i < len; i++)
{
type_instances = this.runtime.types_by_index[i].instances;
for (k = 0, lenk = type_instances.length; k < lenk; k++)
{
inst = type_instances[k];
if (inst.layer)
{
var num = inst.layer.number;
if (num >= this.layers.length)
num = this.layers.length - 1;
inst.layer = this.layers[num];
inst.layer.instances.push(inst);
inst.layer.zindices_stale = true;
}
}
}
for (i = 0, len = this.layers.length; i < len; i++)
{
this.layers[i].createInitialInstances();
}
for (i = 0, len = this.initial_nonworld.length; i < len; i++)
{
inst = this.runtime.createInstanceFromInit(this.initial_nonworld[i], null, true);
;
}
this.runtime.trigger(cr.system_object.prototype.cnds.OnLayoutStart, null);
};
layoutProto.createGlobalNonWorlds = function ()
{
var i, k, len, initial_inst, inst, type;
for (i = 0, k = 0, len = this.initial_nonworld.length; i < len; i++)
{
initial_inst = this.initial_nonworld[i];
type = this.runtime.types_by_index[initial_inst[1]];
if (type.global)
inst = this.runtime.createInstanceFromInit(initial_inst, null, true);
else
{			
this.initial_nonworld[k] = initial_inst;
k++;
}
}
this.initial_nonworld.length = k;
};
layoutProto.stopRunning = function ()
{
;
this.runtime.trigger(cr.system_object.prototype.cnds.OnLayoutEnd, null);
this.runtime.system.waits.length = 0;
var i, leni, j, lenj;
var layer_instances, inst;
for (i = 0, leni = this.layers.length; i < leni; i++)
{
layer_instances = this.layers[i].instances;
for (j = 0, lenj = layer_instances.length; j < lenj; j++)
{
inst = layer_instances[j];
if (!inst.type.global)
this.runtime.DestroyInstance(inst);
}
this.runtime.ClearDeathRow();
layer_instances.length = 0;
this.layers[i].zindices_stale = true;
}
};
layoutProto.draw = function (ctx)
{
ctx.clearRect(0, 0, this.runtime.width, this.runtime.height);
var i, len;
for (i = 0, len = this.layers.length; i < len; i++)
{
if (this.layers[i].visible)
this.layers[i].draw(ctx);
}
};
layoutProto.drawGL = function (glw)
{
glw.clear(0, 0, 0, 0);
var i, len;
for (i = 0, len = this.layers.length; i < len; i++)
{
if (this.layers[i].visible)
this.layers[i].drawGL(glw);
}
glw.present();
};
layoutProto.getMinLayerScale = function ()
{
var m = this.layers[0].getScale();
var i, len, l;
for (i = 1, len = this.layers.length; i < len; i++)
{
l = this.layers[i];
if (l.parallaxX === 0 && l.parallaxY === 0)
continue;
if (l.getScale() < m)
m = l.getScale();
}
return m;
};
layoutProto.scrollToX = function (x)
{
if (!this.unbounded_scrolling)
{
var widthBoundary = (this.runtime.width * (1 / this.getMinLayerScale()) / 2);
if (x > this.width - widthBoundary)
x = this.width - widthBoundary;
if (x < widthBoundary)
x = widthBoundary;
}
if (this.scrollX !== x)
{
this.scrollX = x;
this.runtime.redraw = true;
}
};
layoutProto.scrollToY = function (y)
{		
if (!this.unbounded_scrolling)
{
var heightBoundary = (this.runtime.height * (1 / this.getMinLayerScale()) / 2);
if (y > this.height - heightBoundary)
y = this.height - heightBoundary;
if (y < heightBoundary)
y = heightBoundary;
}
if (this.scrollY !== y)
{
this.scrollY = y;
this.runtime.redraw = true;
}
};
cr.layer = function (layout, m)
{
this.layout = layout;
this.runtime = layout.runtime;
this.instances = [];        // running instances
this.scale = 1.0;
this.angle = 0;
this.disableAngle = false;
this.tmprect = new cr.rect(0, 0, 0, 0);
this.tmpquad = new cr.quad();
this.viewLeft = 0;
this.viewRight = 0;
this.viewTop = 0;
this.viewBottom = 0;
this.zindices_stale = false;
this.name = m[0];
this.index = m[1];
this.visible = m[2];		// initially visible
this.background_color = m[3];
this.transparent = m[4];
this.parallaxX = m[5];
this.parallaxY = m[6];
this.opacity = m[7];
this.forceOwnTexture = m[8];
this.zoomRate = m[9];
var im = m[10];
var i, len;
this.initial_instances = [];
for (i = 0, len = im.length; i < len; i++)
{
var inst = im[i];
var type = this.runtime.types_by_index[inst[1]];
;
if (!type.default_instance)
type.default_instance = inst;
this.initial_instances.push(inst);
}		
};
var layerProto = cr.layer.prototype;
layerProto.createInitialInstances = function ()
{
var i, k, len, inst;
for (i = 0, k = 0, len = this.initial_instances.length; i < len; i++)
{
inst = this.runtime.createInstanceFromInit(this.initial_instances[i], this, true);
if (!inst.type.global)
{
this.initial_instances[k] = this.initial_instances[i];
k++;
}
}
this.initial_instances.length = k;
};
layerProto.updateZIndices = function ()
{
if (!this.zindices_stale)
return;
var i, len;
for (i = 0, len = this.instances.length; i < len; i++)
{
;
this.instances[i].zindex = i;
}
this.zindices_stale = false;
};
layerProto.getScale = function ()
{
return ((this.scale * this.layout.scale * this.runtime.aspect_scale) - 1) * this.zoomRate + 1;
};
layerProto.getAngle = function ()
{
if (this.disableAngle)
return 0;
return cr.clamp_angle(this.layout.angle + this.angle);
};
layerProto.draw = function (ctx)
{
var render_offscreen = (this.forceOwnTexture || this.opacity !== 1.0);
var layer_canvas = this.runtime.canvas;
var layer_ctx = ctx;
if (render_offscreen)
{
if (!this.runtime.layer_canvas)
{
this.runtime.layer_canvas = document.createElement("canvas");
;
layer_canvas = this.runtime.layer_canvas;
layer_canvas.width = this.runtime.width;
layer_canvas.height = this.runtime.height;
this.runtime.layer_ctx = layer_canvas.getContext("2d");
;
}
layer_canvas = this.runtime.layer_canvas;
layer_ctx = this.runtime.layer_ctx;
if (layer_canvas.width !== this.runtime.width)
layer_canvas.width = this.runtime.width;
if (layer_canvas.height !== this.runtime.height)
layer_canvas.height = this.runtime.height;
if (this.transparent)
layer_ctx.clearRect(0, 0, this.runtime.width, this.runtime.height);
}
if (!this.transparent)
{
layer_ctx.fillStyle = "rgb(" + this.background_color[0] + "," + this.background_color[1] + "," + this.background_color[2] + ")";
layer_ctx.fillRect(0, 0, this.runtime.width, this.runtime.height);
}
layer_ctx.save();
this.disableAngle = true;
var px = this.canvasToLayer(0, 0, true);
var py = this.canvasToLayer(0, 0, false);
this.disableAngle = false;
if (this.runtime.pixel_rounding)
{
px = Math.round(px);
py = Math.round(py);
}
this.rotateViewport(px, py, layer_ctx);
var myscale = this.getScale();
layer_ctx.scale(myscale, myscale);
layer_ctx.translate(-px, -py);
var i, len, inst, bbox;
for (i = 0, len = this.instances.length; i < len; i++)
{
inst = this.instances[i];
if (!inst.visible || inst.width === 0 || inst.height === 0)
continue;
inst.update_bbox();
bbox = inst.bbox;
if (bbox.right < this.viewLeft || bbox.bottom < this.viewTop || bbox.left > this.viewRight || bbox.top > this.viewBottom)
continue;
inst.draw(layer_ctx);
}
layer_ctx.restore();
if (render_offscreen)
{
ctx.globalAlpha = this.opacity;
ctx.drawImage(layer_canvas, 0, 0);
ctx.globalAlpha = 1.0;
}
};
layerProto.rotateViewport = function (px, py, ctx)
{
var myscale = this.getScale();
this.viewLeft = px;
this.viewTop = py;
this.viewRight = px + (this.runtime.width * (1 / myscale));
this.viewBottom = py + (this.runtime.height * (1 / myscale));
var myAngle = this.getAngle();
if (myAngle !== 0)
{
ctx.translate(this.runtime.width / 2, this.runtime.height / 2);
ctx.rotate(-myAngle);
ctx.translate(this.runtime.width / -2, this.runtime.height / -2);
this.tmprect.set(this.viewLeft, this.viewTop, this.viewRight, this.viewBottom);
this.tmprect.offset((this.viewLeft + this.viewRight) / -2, (this.viewTop + this.viewBottom) / -2);
this.tmpquad.set_from_rotated_rect(this.tmprect, myAngle);
this.tmpquad.bounding_box(this.tmprect);
this.tmprect.offset((this.viewLeft + this.viewRight) / 2, (this.viewTop + this.viewBottom) / 2);
this.viewLeft = this.tmprect.left;
this.viewTop = this.tmprect.top;
this.viewRight = this.tmprect.right;
this.viewBottom = this.tmprect.bottom;
}
}
layerProto.drawGL = function (glw)
{
var overlay_ctx = this.runtime.overlay_ctx;
var render_offscreen = (this.forceOwnTexture || this.opacity !== 1.0);
if (render_offscreen)
{
if (!this.runtime.layer_tex)
{
this.runtime.layer_tex = glw.createEmptyTexture(this.runtime.width, this.runtime.height);
}
if (this.runtime.layer_tex.c2width !== this.runtime.width || this.runtime.layer_tex.c2height !== this.runtime.height)
{
glw.deleteTexture(this.runtime.layer_tex);
this.runtime.layer_tex = glw.createEmptyTexture(this.runtime.width, this.runtime.height);
}
glw.setRenderingToTexture(this.runtime.layer_tex);
if (this.transparent)
glw.clear(0, 0, 0, 0);
}
if (!this.transparent)
{
glw.clear(this.background_color[0] / 255, this.background_color[1] / 255, this.background_color[2] / 255, 1);
}
overlay_ctx.save();
this.disableAngle = true;
var px = this.canvasToLayer(0, 0, true);
var py = this.canvasToLayer(0, 0, false);
this.disableAngle = false;
if (this.runtime.pixel_rounding)
{
px = Math.round(px);
py = Math.round(py);
}
this.rotateViewport(px, py, overlay_ctx);
var myscale = this.getScale();
overlay_ctx.scale(myscale, myscale);
overlay_ctx.translate(-px, -py);
glw.resetModelView();
glw.scale(myscale, myscale);
glw.rotateZ(-this.getAngle());
glw.translate((this.viewLeft + this.viewRight) / -2, (this.viewTop + this.viewBottom) / -2);
glw.updateModelView();
var i, len, inst, bbox;
for (i = 0, len = this.instances.length; i < len; i++)
{
inst = this.instances[i];
if (!inst.visible || inst.width === 0 || inst.height === 0)
continue;
inst.update_bbox();
bbox = inst.bbox;
if (bbox.right < this.viewLeft || bbox.bottom < this.viewTop || bbox.left > this.viewRight || bbox.top > this.viewBottom)
continue;
inst.drawGL(glw);
}
overlay_ctx.restore();
if (render_offscreen)
{
glw.setRenderingToTexture(null);
glw.setOpacity(this.opacity);
glw.setTexture(this.runtime.layer_tex);
glw.setAlphaBlend();
glw.resetModelView();
glw.updateModelView();
var halfw = this.runtime.width / 2;
var halfh = this.runtime.height / 2;
glw.quad(-halfw, halfh, halfw, halfh, halfw, -halfh, -halfw, -halfh);
glw.setTexture(null);
}
};
layerProto.canvasToLayer = function (ptx, pty, getx)
{
var ox = (this.runtime.width / 2);
var oy = (this.runtime.height / 2);
var x = ((this.layout.scrollX - ox) * this.parallaxX) + ox;
var y = ((this.layout.scrollY - oy) * this.parallaxY) + oy;
var invScale = 1 / this.getScale();
x -= (this.runtime.width * invScale) / 2;
y -= (this.runtime.height * invScale) / 2;
x += ptx * invScale;
y += pty * invScale;
var a = this.getAngle();
if (a !== 0)
{
x -= this.layout.scrollX;
y -= this.layout.scrollY;
var cosa = Math.cos(a);
var sina = Math.sin(a);
var x_temp = (x * cosa) - (y * sina);
y = (y * cosa) + (x * sina);
x = x_temp;
x += this.layout.scrollX;
y += this.layout.scrollY;
}
return getx ? x : y;
};
layerProto.layerToCanvas = function (ptx, pty, getx)
{
var ox = (this.runtime.width / 2);
var oy = (this.runtime.height / 2);
var x = ((this.layout.scrollX - ox) * this.parallaxX) + ox;
var y = ((this.layout.scrollY - oy) * this.parallaxY) + oy;
var invScale = 1 / this.getScale();
x -= (this.runtime.width * invScale) / 2;
y -= (this.runtime.height * invScale) / 2;
x = ptx / invScale - x;
y = pty / invScale - y;
var a = this.getAngle();
if (a !== 0)
{
x -= ox;
y -= oy;
var cosa = Math.cos(-a);
var sina = Math.sin(-a);
var x_temp = (x * cosa) - (y * sina);
y = (y * cosa) + (x * sina);
x = x_temp;
x += ox;
y += oy;
}
return getx ? x : y;
};
}());
;
(function()
{
cr.eventsheet = function (runtime, m)
{
this.runtime = runtime;
this.triggers = {};
this.hasRun = false;
this.hasTriggered = false;
this.includes = new cr.ObjectSet(); // all event sheets included by this sheet, at first-level indirection only
this.name = m[0];
var em = m[1];		// events model
this.events = [];       // triggers won't make it to this array
var i, len;
for (i = 0, len = em.length; i < len; i++)
this.init_event(em[i], null, this.events);
};
var eventSheetProto = cr.eventsheet.prototype;
eventSheetProto.toString = function ()
{
return this.name;
};
eventSheetProto.init_event = function (m, parent, nontriggers)
{
switch (m[0]) {
case 0:	// event block
{
var block = new cr.eventblock(this, parent, m);
cr.seal(block);
if (block.is_trigger())
this.init_trigger(block);
else
nontriggers.push(block);
break;
}
case 1: // variable
{
var v = new cr.eventvariable(this, parent, m);
cr.seal(v);
nontriggers.push(v);
break;
}
case 2:	// include
{
var inc = new cr.eventinclude(this, parent, m);
cr.seal(inc);
nontriggers.push(inc);
break;
}
default:
;
}
};
eventSheetProto.postInit = function ()
{
var i, len;
for (i = 0, len = this.events.length; i < len; i++)
{
this.events[i].postInit();
}
};
eventSheetProto.run = function ()
{
this.hasRun = true;
var i, len;
for (i = 0, len = this.events.length; i < len; i++)
{
var ev = this.events[i];
ev.run();
this.runtime.clearSol(ev.solModifiers);
}
};
cr.selection = function (type)
{
this.type = type;
this.instances = [];        // subset of picked instances
this.select_all = true;
};
var solProto = cr.selection.prototype;
solProto.hasObjects = function ()
{
if (this.select_all)
return this.type.instances.length;
else
return this.instances.length;
};
solProto.getObjects = function ()
{
if (this.select_all)
return this.type.instances;
else
return this.instances;
};
solProto.pick = function (inst)
{
;
if (this.select_all)
{
this.select_all = false;
this.instances.length = 1;
this.instances[0] = inst;
}
else
{
if (jQuery.inArray(inst, this.instances) === -1)
this.instances.push(inst);
}
};
var runtimeProto = cr.runtime.prototype;
runtimeProto.clearSol = function (solModifiers)
{
var i, len;
for (i = 0, len = solModifiers.length; i < len; i++)
{
solModifiers[i].getCurrentSol().select_all = true;
}
};
runtimeProto.pushCleanSol = function (solModifiers)
{
var i, len;
for (i = 0, len = solModifiers.length; i < len; i++)
{
solModifiers[i].pushCleanSol();
}
};
runtimeProto.pushCopySol = function (solModifiers)
{
var i, len;
for (i = 0, len = solModifiers.length; i < len; i++)
{
solModifiers[i].pushCopySol();
}
};
runtimeProto.popSol = function (solModifiers)
{
var i, len;
for (i = 0, len = solModifiers.length; i < len; i++)
{
solModifiers[i].popSol();
}
};
cr.eventblock = function (sheet, parent, m)
{
this.sheet = sheet;
this.parent = parent;
this.runtime = sheet.runtime;
this.solModifiers = [];
this.solWriterAfterCnds = false;	// block does not change SOL after running its conditions
;
this.conditions = [];
this.actions = [];
this.subevents = [];
if (m[1])
{
this.group_name = m[1][1].toLowerCase();
if (m[1][0])
this.runtime.activeGroups[this.group_name] = true;
}
var i, len;
var cm = m[2];
for (i = 0, len = cm.length; i < len; i++)
{
var cnd = new cr.condition(this, cm[i]);
cr.seal(cnd);
this.conditions.push(cnd);
this.addSolModifier(cnd.type);
}
var am = m[3];
for (i = 0, len = am.length; i < len; i++)
{
var act = new cr.action(this, am[i]);
cr.seal(act);
this.actions.push(act);
}
if (m.length === 5)
{
var em = m[4];
for (i = 0, len = em.length; i < len; i++)
this.sheet.init_event(em[i], this, this.subevents);
}
};
var eventblockProto = cr.eventblock.prototype;
eventblockProto.postInit = function ()
{
var i, len;
for (i = 0, len = this.conditions.length; i < len; i++)
this.conditions[i].postInit();
for (i = 0, len = this.actions.length; i < len; i++)
this.actions[i].postInit();
for (i = 0, len = this.subevents.length; i < len; i++)
this.subevents[i].postInit();
}
eventblockProto.addSolModifier = function (type)
{
if (!type)
return;
if (jQuery.inArray(type, this.solModifiers) === -1)
this.solModifiers.push(type);
};
eventblockProto.setSolWriterAfterCnds = function ()
{
this.solWriterAfterCnds = true;
if (this.parent)
this.parent.setSolWriterAfterCnds();
};
eventblockProto.is_trigger = function ()
{
if (!this.conditions.length)    // no conditions
return false;
else
return this.conditions[0].trigger;
};
eventblockProto.run = function ()
{
var i, len;
var evinfo = this.runtime.getCurrentEventStack();
evinfo.current_event = this;
for (evinfo.cndindex = 0, len = this.conditions.length; evinfo.cndindex < len; evinfo.cndindex++)
{
if (!this.conditions[evinfo.cndindex].run())    // condition failed
return false;                               // bail out
}
this.run_actions_and_subevents();
};
eventblockProto.run_actions_and_subevents = function ()
{
var evinfo = this.runtime.getCurrentEventStack();
var len;
for (evinfo.actindex = 0, len = this.actions.length; evinfo.actindex < len; evinfo.actindex++)
{
if (this.actions[evinfo.actindex].run())
return;
}
this.run_subevents();
};
eventblockProto.resume_actions_and_subevents = function ()
{
var evinfo = this.runtime.getCurrentEventStack();
var len;
for (len = this.actions.length; evinfo.actindex < len; evinfo.actindex++)
{
if (this.actions[evinfo.actindex].run())
return;
}
this.run_subevents();
};
eventblockProto.run_subevents = function ()
{
if (!this.subevents.length)
return;
var i, len, subev, pushpop;
var last = this.subevents.length - 1;
if (this.solWriterAfterCnds)
{
for (i = 0, len = this.subevents.length; i < len; i++)
{
subev = this.subevents[i];
pushpop = (!this.group && i < last);
if (pushpop)
this.runtime.pushCopySol(subev.solModifiers);
subev.run();
if (pushpop)
this.runtime.popSol(subev.solModifiers);
else
this.runtime.clearSol(subev.solModifiers);
}
}
else
{
for (i = 0, len = this.subevents.length; i < len; i++)
{
this.subevents[i].run();
}
}
};
eventblockProto.run_pretrigger = function ()
{
var evinfo = this.runtime.getCurrentEventStack();
evinfo.current_event = this;
var i, len;
for (evinfo.cndindex = 0, len = this.conditions.length; evinfo.cndindex < len; evinfo.cndindex++)
{
;
if (!this.conditions[evinfo.cndindex].run())  // condition failed
return false;               // bail out
}
return true;
};
eventblockProto.retrigger = function ()
{
this.runtime.execcount++;
var prevcndindex = this.runtime.getCurrentEventStack().cndindex;
var len;
var evinfo = this.runtime.pushEventStack(this);
for (evinfo.cndindex = prevcndindex + 1, len = this.conditions.length; evinfo.cndindex < len; evinfo.cndindex++)
{
if (!this.conditions[evinfo.cndindex].run())    // condition failed
{
this.runtime.popEventStack();               // moving up level of recursion
return false;                               // bail out
}
}
this.run_actions_and_subevents();
this.runtime.popEventStack();
};
cr.condition = function (block, m)
{
this.block = block;
this.sheet = block.sheet;
this.runtime = block.runtime;
this.parameters = [];
this.results = [];
this.extra = {};		// for plugins to stow away some custom info
this.func = m[1];
;
this.trigger = m[3];
this.looping = m[4];
this.inverted = m[5];
this.isstatic = m[6];
if (m[0] === -1)		// system object
{
this.type = null;
this.run = this.run_system;
}
else
{
this.type = this.runtime.types_by_index[m[0]];
;
if (this.isstatic)
this.run = this.run_static;
else
this.run = this.run_object;
if (m[2])
{
this.behaviortype = this.type.getBehaviorByName(m[2]);
;
this.beh_index = this.type.getBehaviorIndexByName(m[2]);
;
}
else
{
this.behaviortype = null;
this.beh_index = -1;
}
if (this.block.parent)
this.block.parent.setSolWriterAfterCnds();
}
if (m.length === 8)
{
var i, len;
var em = m[7];
for (i = 0, len = em.length; i < len; i++)
{
var param = new cr.parameter(this, em[i]);
cr.seal(param);
this.parameters.push(param);
}
this.results.length = em.length;
}
};
var conditionProto = cr.condition.prototype;
conditionProto.postInit = function ()
{
var i, len;
for (i = 0, len = this.parameters.length; i < len; i++)
this.parameters[i].postInit();
};
conditionProto.run_system = function ()
{
var i, len;
for (i = 0, len = this.parameters.length; i < len; i++)
this.results[i] = this.parameters[i].get();
return cr.xor(this.func.apply(this.runtime.system, this.results), this.inverted);
};
conditionProto.run_static = function ()
{
var i, len;
for (i = 0, len = this.parameters.length; i < len; i++)
this.results[i] = this.parameters[i].get();
return this.func.apply(this.type, this.results);
};
conditionProto.run_object = function ()
{
var i, j, leni, lenj, ret, inst;
var sol = this.type.getCurrentSol();
if (sol.select_all) {
sol.instances.length = 0;       // clear contents
for (i = 0, leni = this.type.instances.length; i < leni; i++) {
inst = this.type.instances[i];
;
for (j = 0, lenj = this.parameters.length; j < lenj; j++)
this.results[j] = this.parameters[j].get(i);        // default SOL index is current object
if (this.beh_index > -1)
ret = this.func.apply(inst.behavior_insts[this.beh_index], this.results);
else
ret = this.func.apply(inst, this.results);
if (cr.xor(ret, this.inverted))
sol.instances.push(inst);
}
sol.select_all = false;
}
else {
var k = 0;
for (i = 0, leni = sol.instances.length; i < leni; i++) {
inst = sol.instances[i];
;
for (j = 0, lenj = this.parameters.length; j < lenj; j++)
this.results[j] = this.parameters[j].get(i);        // default SOL index is current object
if (this.beh_index > -1)
ret = this.func.apply(inst.behavior_insts[this.beh_index], this.results);
else
ret = this.func.apply(inst, this.results);
if (cr.xor(ret, this.inverted)) {
sol.instances[k] = inst;
k++;
}
}
sol.instances.length = k;
}
return sol.hasObjects();
};
cr.action = function (block, m)
{
this.block = block;
this.sheet = block.sheet;
this.runtime = block.runtime;
this.parameters = [];
this.results = [];
this.extra = {};		// for plugins to stow away some custom info
this.func = m[1];
;
if (m[0] === -1)	// system
{
this.type = null;
this.run = this.run_system;
}
else
{
this.type = this.runtime.types_by_index[m[0]];
;
this.run = this.run_object;
if (m[2])
{
this.behaviortype = this.type.getBehaviorByName(m[2]);
;
this.beh_index = this.type.getBehaviorIndexByName(m[2]);
;
}
else
{
this.behaviortype = null;
this.beh_index = -1;
}
}
if (m.length === 4)
{
var i, len;
var em = m[3];
for (i = 0, len = em.length; i < len; i++)
{
var param = new cr.parameter(this, em[i]);
cr.seal(param);
this.parameters.push(param);
}
this.results.length = em.length;
}
};
var actionProto = cr.action.prototype;
actionProto.postInit = function ()
{
var i, len;
for (i = 0, len = this.parameters.length; i < len; i++)
this.parameters[i].postInit();
};
actionProto.run_system = function ()
{
var i, len;
for (i = 0, len = this.parameters.length; i < len; i++)
this.results[i] = this.parameters[i].get();
return this.func.apply(this.runtime.system, this.results);
};
actionProto.run_object = function ()
{
var instances = this.type.getCurrentSol().getObjects();
var i, j, leni, lenj;
for (i = 0, leni = instances.length; i < leni; i++)
{
for (j = 0, lenj = this.parameters.length; j < lenj; j++)
this.results[j] = this.parameters[j].get(i);    // pass i to use as default SOL index
if (this.beh_index > -1)
this.func.apply(instances[i].behavior_insts[this.beh_index], this.results);
else
this.func.apply(instances[i], this.results);
}
return false;
};
cr.parameter = function (owner, m)
{
this.owner = owner;
this.block = owner.block;
this.sheet = owner.sheet;
this.runtime = owner.runtime;
this.type = m[0];
switch (m[0])
{
case 0:		// number
case 1:		// string
case 7:		// any
this.expression = new cr.expNode(this, m[1]);
this.solindex = 0;
this.get = this.get_exp;
this.temp = new cr.expvalue();
break;
case 5:		// layer
this.expression = new cr.expNode(this, m[1]);
this.solindex = 0;
this.get = this.get_layer;
this.temp = new cr.expvalue();
break;
case 3:		// combo
case 8:		// cmp
this.combosel = m[1];
this.get = this.get_combosel;
break;
case 6:		// layout
this.layout = this.runtime.layouts[m[1]];
;
this.get = this.get_layout;
break;
case 9:		// keyb
this.key = m[1];
this.get = this.get_key;
break;
case 4:		// object
this.object = this.runtime.types_by_index[m[1]];
;
this.get = this.get_object;
this.block.addSolModifier(this.object);
if (this.owner instanceof cr.action)
this.block.setSolWriterAfterCnds();
else if (this.block.parent)
this.block.parent.setSolWriterAfterCnds();
break;
case 10:	// instvar
this.index = m[1];
this.get = this.get_instvar;
break;
case 11:	// eventvar
this.varname = m[1];
this.eventvar = null;
this.get = this.get_eventvar;
break;
case 2:		// audiofile
this.fileinfo = m[1];
this.get = this.get_audiofile;
break;
default:
;
}
};
var parameterProto = cr.parameter.prototype;
parameterProto.postInit = function ()
{
if (this.type === 11)	// eventvar
{
this.eventvar = this.runtime.getEventVariableByName(this.varname, this.block.parent);
;
}
if (this.expression)
this.expression.postInit();
};
parameterProto.get_exp = function (solindex)
{
this.solindex = solindex || 0;   // default SOL index to use
this.expression.get(this.temp)
return this.temp.data;      // return actual JS value, not expvalue
};
parameterProto.get_object = function ()
{
return this.object;
};
parameterProto.get_combosel = function ()
{
return this.combosel;
};
parameterProto.get_layer = function (solindex)
{
this.solindex = solindex || 0;   // default SOL index to use
this.expression.get(this.temp)
if (this.temp.is_number())
return this.runtime.getLayerByNumber(this.temp.data);
else
return this.runtime.getLayerByName(this.temp.data);
}
parameterProto.get_layout = function ()
{
return this.layout;
};
parameterProto.get_key = function ()
{
return this.key;
};
parameterProto.get_instvar = function ()
{
return this.index;
};
parameterProto.get_eventvar = function ()
{
return this.eventvar;
};
parameterProto.get_audiofile = function ()
{
return this.fileinfo;
};
cr.eventvariable = function (sheet, parent, m)
{
this.sheet = sheet;
this.parent = parent;
this.runtime = sheet.runtime;
this.solModifiers = [];
if (!this.parent)		// global var
this.runtime.all_global_vars.push(this);
this.name = m[1];
this.vartype = m[2];
this.initial = m[3];
this.data = this.initial;
};
var eventvariableProto = cr.eventvariable.prototype;
eventvariableProto.postInit = function ()
{
};
eventvariableProto.run = function ()
{
if (this.parent)
this.data = this.initial;
};
cr.eventinclude = function (sheet, parent, m)
{
this.sheet = sheet;
this.parent = parent;
this.runtime = sheet.runtime;
this.solModifiers = [];
this.include_sheet = null;		// determined in postInit
this.include_sheet_name = m[1];
};
var eventincludeProto = cr.eventinclude.prototype;
eventincludeProto.postInit = function ()
{
this.include_sheet = this.runtime.eventsheets[this.include_sheet_name];
;
;
this.sheet.includes.add(this.include_sheet);
};
eventincludeProto.run = function ()
{
if (this.parent)
this.runtime.pushCleanSol(this.runtime.types_by_index);
if (!this.include_sheet.hasRun)
this.include_sheet.run();
if (this.parent)
this.runtime.popSol(this.runtime.types_by_index);
};
runtimeProto.testAndSelectCanvasPointOverlap = function (type, ptx, pty, inverted)
{
var sol = type.getCurrentSol();
var i, j, inst, len;
var lx, ly;
if (sol.select_all)
{
if (!inverted)
{
sol.select_all = false;
sol.instances.length = 0;   // clear contents
}
for (i = 0, len = type.instances.length; i < len; i++)
{
inst = type.instances[i];
inst.update_bbox();
lx = inst.layer.canvasToLayer(ptx, pty, true);
ly = inst.layer.canvasToLayer(ptx, pty, false);
if (inst.contains_pt(lx, ly))
{
if (inverted)
return false;
else
sol.instances.push(inst);
}
}
}
else
{
j = 0;
for (i = 0, len = sol.instances.length; i < len; i++)
{
inst = sol.instances[i];
inst.update_bbox();
lx = inst.layer.canvasToLayer(ptx, pty, true);
ly = inst.layer.canvasToLayer(ptx, pty, false);
if (inst.contains_pt(lx, ly))
{
if (inverted)
return false;
else
{
sol.instances[j] = sol.instances[i];
j++;
}
}
}
if (!inverted)
sol.instances.length = j;
}
if (inverted)
return true;		// did not find anything overlapping
else
return sol.hasObjects();
};
runtimeProto.testOverlap = function (a, b)
{
if (!a || !b)
return false;
if (a === b)
return false;
a.update_bbox();
b.update_bbox();
if (!a.bbox.intersects_rect(b.bbox))
return false;
if (!a.bquad.intersects_quad(b.bquad))
return false;
var haspolya = (a.collision_poly && !a.collision_poly.is_empty());
var haspolyb = (b.collision_poly && !b.collision_poly.is_empty());
if (!haspolya && !haspolyb)
return true;
var polya, polyb;
if (haspolya)
{
a.collision_poly.cache_poly(a.width, a.height, a.angle);
polya = a.collision_poly;
}
else
{
this.temp_poly.set_from_quad(a.bquad, a.x, a.y, a.width, a.height);
polya = this.temp_poly;
}
if (haspolyb)
{
b.collision_poly.cache_poly(b.width, b.height, b.angle);
polyb = b.collision_poly;
}
else
{
this.temp_poly.set_from_quad(b.bquad, b.x, b.y, b.width, b.height);
polyb = this.temp_poly;
}
return polya.intersects_poly(polyb, b.x - a.x, b.y - a.y);
};
runtimeProto.testOverlapSolid = function (inst)
{
var solid = null;
var i, len, s;
if (!cr.behaviors.solid)
return null;
for (i = 0, len = this.behaviors.length; i < len; i++)
{
if (this.behaviors[i] instanceof cr.behaviors.solid)
{
solid = this.behaviors[i];
break;
}
}
if (!solid)
return null;
var solids = solid.my_instances.valuesRef();
for (i = 0, len = solids.length; i < len; ++i)
{
s = solids[i];
if (!s.extra.solidEnabled)
continue;
if (this.testOverlap(inst, s))
return s;
}
return null;
};
runtimeProto.testOverlapJumpThru = function (inst)
{
var jumpthru = null;
var i, len, s;
if (!cr.behaviors.jumpthru)
return null;
for (i = 0, len = this.behaviors.length; i < len; i++)
{
if (this.behaviors[i] instanceof cr.behaviors.jumpthru)
{
jumpthru = this.behaviors[i];
break;
}
}
if (!jumpthru)
return null;
var jumpthrus = jumpthru.my_instances.valuesRef();
for (i = 0, len = jumpthrus.length; i < len; ++i)
{
s = jumpthrus[i];
if (!s.extra.jumpthruEnabled)
continue;
if (this.testOverlap(inst, s))
return s;
}
return null;
};
runtimeProto.pushOutSolid = function (inst, xdir, ydir, dist, include_jumpthrus)
{
var push_dist = dist || 50;
var oldx = inst.x
var oldy = inst.y;
var i;
var last_overlapped = null;
for (i = 0; i < push_dist; i++)
{
inst.x = Math.floor(oldx + (xdir * i));
inst.y = Math.floor(oldy + (ydir * i));
inst.set_bbox_changed();
if (!this.testOverlap(inst, last_overlapped))
{
last_overlapped = this.testOverlapSolid(inst);
if (!last_overlapped)
{
if (include_jumpthrus)
last_overlapped = this.testOverlapJumpThru(inst);
if (!last_overlapped)
return true;
}
}
}
inst.x = oldx;
inst.y = oldy;
inst.set_bbox_changed();
return false;
};
runtimeProto.pushOutSolidNearest = function (inst, max_dist_)
{
var max_dist = (cr.is_undefined(max_dist_) ? 100 : max_dist_);
var dist = 0;
var oldx = inst.x
var oldy = inst.y;
var dir = 0;
var dx = 0, dy = 0;
var last_overlapped = null;
while (dist <= max_dist)
{
switch (dir) {
case 0:		dx = 0; dy = -1; dist++; break;
case 1:		dx = 1; dy = -1; break;
case 2:		dx = 1; dy = 0; break;
case 3:		dx = 1; dy = 1; break;
case 4:		dx = 0; dy = 1; break;
case 5:		dx = -1; dy = 1; break;
case 6:		dx = -1; dy = 0; break;
case 7:		dx = -1; dy = -1; break;
}
dir = (dir + 1) % 8;
inst.x = Math.floor(oldx + (dx * dist));
inst.y = Math.floor(oldy + (dy * dist));
inst.set_bbox_changed();
if (!this.testOverlap(inst, last_overlapped))
{
last_overlapped = this.testOverlapSolid(inst);
if (!last_overlapped)
return true;
}
}
inst.x = oldx;
inst.y = oldy;
inst.set_bbox_changed();
return false;
};
runtimeProto.registerCollision = function (a, b)
{
this.registered_collisions.push([a, b]);
};
runtimeProto.checkRegisteredCollision = function (a, b)
{
var i, len, x;
for (i = 0, len = this.registered_collisions.length; i < len; i++)
{
x = this.registered_collisions[i];
if ((x[0] == a && x[1] == b) || (x[0] == b && x[1] == a))
return true;
}
return false;
};
runtimeProto.calculateSolidBounceAngle = function(inst, startx, starty, obj)
{
var objx = inst.x;
var objy = inst.y;
var radius = cr.distanceTo(startx, starty, objx, objy);
var startangle = cr.angleTo(startx, starty, objx, objy);
var firstsolid = obj || this.testOverlapSolid(inst);
if (!firstsolid)
return cr.clamp_angle(startangle + Math.PI);
var cursolid = firstsolid;
var i, curangle, anticlockwise_free_angle, clockwise_free_angle;
var increment = cr.to_radians(5);	// 5 degree increments
for (i = 1; i < 36; i++)
{
curangle = startangle - i * increment;
inst.x = startx + Math.cos(curangle) * radius;
inst.y = starty + Math.sin(curangle) * radius;
inst.set_bbox_changed();
if (!this.testOverlap(inst, cursolid))
{
cursolid = obj ? null : this.testOverlapSolid(inst);
if (!cursolid)
{
anticlockwise_free_angle = curangle;
break;
}
}
}
if (i === 36)
anticlockwise_free_angle = cr.clamp_angle(startangle + Math.PI);
var cursolid = firstsolid;
for (i = 1; i < 36; i++)
{
curangle = startangle + i * increment;
inst.x = startx + Math.cos(curangle) * radius;
inst.y = starty + Math.sin(curangle) * radius;
inst.set_bbox_changed();
if (!this.testOverlap(inst, cursolid))
{
cursolid = obj ? null : this.testOverlapSolid(inst);
if (!cursolid)
{
clockwise_free_angle = curangle;
break;
}
}
}
if (i === 36)
clockwise_free_angle = cr.clamp_angle(startangle + Math.PI);
inst.x = objx;
inst.y = objy;
inst.set_bbox_changed();
if (clockwise_free_angle === anticlockwise_free_angle)
return clockwise_free_angle;
var half_diff = cr.angleDiff(clockwise_free_angle, anticlockwise_free_angle) / 2;
var normal;
if (cr.angleClockwise(clockwise_free_angle, anticlockwise_free_angle))
{
normal = cr.clamp_angle(anticlockwise_free_angle + half_diff + Math.PI);
}
else
{
normal = cr.clamp_angle(clockwise_free_angle + half_diff);
}
;
var vx = Math.cos(startangle);
var vy = Math.sin(startangle);
var nx = Math.cos(normal);
var ny = Math.sin(normal);
var v_dot_n = vx * nx + vy * ny;
var rx = vx - 2 * v_dot_n * nx;
var ry = vy - 2 * v_dot_n * ny;
return cr.angleTo(0, 0, rx, ry);
};
eventSheetProto.init_trigger = function (trig)
{
;
this.runtime.triggers_to_postinit.push(trig);
var type_name;
if (trig.conditions[0].type)
type_name = trig.conditions[0].type.name;
else
type_name = "system";
if (!this.triggers[type_name])
this.triggers[type_name] = [];
var obj_entry = this.triggers[type_name];
var method = trig.conditions[0].func;
var i, len;
for (i = 0, len = obj_entry.length; i < len; i++)
{
if (obj_entry[i].method == method)
{
obj_entry[i].evs.push(trig);
return;
}
}
obj_entry.push({ method: method, evs: [trig]});
};
runtimeProto.trigger = function (method, inst)
{
;
if (!this.running_layout)
return false;
var sheet = this.running_layout.event_sheet;
if (!sheet)
return false;     // no event sheet active; nothing to trigger
var i, len;
for (i = 0, len = this.eventsheets_by_index.length; i < len; i++)
this.eventsheets_by_index[i].hasTriggered = false;
return this.triggerOnSheet(method, inst, sheet);
};
runtimeProto.triggerOnSheet = function (method, inst, sheet)
{
if (sheet.hasTriggered)
return false;
sheet.hasTriggered = true;
var includes = sheet.includes.valuesRef();
var ret = false;
var i, j, leni, lenj;
for (i = 0, leni = includes.length; i < leni; i++)
{
var r = this.triggerOnSheet(method, inst, includes[i]);
ret = ret || r;
}
var type_name;
if (!inst)
type_name = "system";
else
type_name = inst.type.name;
if (!sheet.triggers[type_name])
return ret;
var obj_entry = sheet.triggers[type_name];
var triggers_list = null;
for (i = 0, leni = obj_entry.length; i < leni; i++)
{
if (obj_entry[i].method == method)
{
triggers_list = obj_entry[i].evs;
break;
}
}
if (!triggers_list)
return ret;
for (i = 0, leni = triggers_list.length; i < leni; i++)
{
var trig = triggers_list[i];
this.pushCleanSol(trig.solModifiers);
this.pushEventStack(trig);
if (inst)
{
var sol = inst.type.getCurrentSol();
sol.select_all = false;
sol.instances.length = 1;
sol.instances[0] = inst;
}
var ok_to_run = true;
if (trig.parent)
{
var temp_parents_arr = this.getCurrentEventStack().temp_parents_arr;
var cur_parent = trig.parent;
while (cur_parent)
{
temp_parents_arr.push(cur_parent);
cur_parent = cur_parent.parent;
}
temp_parents_arr.reverse();
for (j = 0, lenj = temp_parents_arr.length; j < lenj; j++)
this.pushCleanSol(temp_parents_arr[j].solModifiers);
for (j = 0, lenj = temp_parents_arr.length; j < lenj; j++)
{
if (!temp_parents_arr[j].run_pretrigger())   // parent event failed
{
ok_to_run = false;
break;
}
}
for (j = 0, lenj = temp_parents_arr.length; j < lenj; j++)
this.popSol(temp_parents_arr[j].solModifiers);
}
if (ok_to_run)
{
this.execcount++;
trig.run();
ret = true;     // something got triggered
}
this.popSol(trig.solModifiers);
this.popEventStack();
}
return ret;             // true if anything got triggered
};
cr.eventStackFrame = function ()
{
this.temp_parents_arr = [];
this.reset(null);
cr.seal(this);
};
var eventStackFrameProto = cr.eventStackFrame.prototype;
eventStackFrameProto.reset = function (cur_event)
{
this.current_event = cur_event;
this.cndindex = 0;
this.actindex = 0;
this.temp_parents_arr.length = 0;
};
eventStackFrameProto.isModifierAfterCnds = function ()
{
if (this.current_event.solWriterAfterCnds)
return true;
if (this.cndindex < this.current_event.conditions.length - 1)
return !!this.current_event.solModifiers.length;
return false;
};
runtimeProto.getCurrentCondition = function ()
{
var evinfo = this.getCurrentEventStack();
return evinfo.current_event.conditions[evinfo.cndindex];
};
runtimeProto.getCurrentAction = function ()
{
var evinfo = this.getCurrentEventStack();
return evinfo.current_event.actions[evinfo.actindex];
};
runtimeProto.pushEventStack = function (cur_event)
{
this.event_stack_index++;
if (this.event_stack_index >= this.event_stack.length)
this.event_stack.push(new cr.eventStackFrame());
var ret = this.getCurrentEventStack();
ret.reset(cur_event);
return ret;
};
runtimeProto.popEventStack = function ()
{
;
this.event_stack_index--;
};
runtimeProto.getCurrentEventStack = function ()
{
return this.event_stack[this.event_stack_index];
};
runtimeProto.pushLoopStack = function (name_)
{
this.loop_stack_index++;
if (this.loop_stack_index >= this.loop_stack.length)
{
this.loop_stack.push(cr.seal({ name: name_, index: 0 }));
}
var ret = this.getCurrentLoop();
ret.name = name_;
ret.index = 0;
return ret;
};
runtimeProto.popLoopStack = function ()
{
;
this.loop_stack_index--;
};
runtimeProto.getCurrentLoop = function ()
{
return this.loop_stack[this.loop_stack_index];
};
runtimeProto.getEventVariableByName = function (name, scope)
{
var i, leni, j, lenj, sheet, e;
while (scope)
{
for (i = 0, leni = scope.subevents.length; i < leni; i++)
{
e = scope.subevents[i];
if (e instanceof cr.eventvariable && name.toLowerCase() === e.name.toLowerCase())
return e;
}
scope = scope.parent;
}
for (i = 0, leni = this.eventsheets_by_index.length; i < leni; i++)
{
sheet = this.eventsheets_by_index[i];
for (j = 0, lenj = sheet.events.length; j < lenj; j++)
{
e = sheet.events[j];
if (e instanceof cr.eventvariable && name.toLowerCase() === e.name.toLowerCase())
return e;
}
}
return null;
};
}());
(function()
{
cr.expNode = function (owner_, m)
{
this.owner = owner_;
this.runtime = owner_.runtime;
this.type = m[0];
;
this.get = [this.eval_int,
this.eval_float,
this.eval_string,
this.eval_unaryminus,
this.eval_add,
this.eval_subtract,
this.eval_multiply,
this.eval_divide,
this.eval_mod,
this.eval_power,
this.eval_and,
this.eval_or,
this.eval_equal,
this.eval_notequal,
this.eval_less,
this.eval_lessequal,
this.eval_greater,
this.eval_greaterequal,
this.eval_conditional,
this.eval_system_exp,
this.eval_object_behavior_exp,
this.eval_instvar_exp,
this.eval_object_behavior_exp,
this.eval_eventvar_exp][this.type];
var paramsModel = null;
this.temp = new cr.expvalue();
switch (this.type) {
case 0:		// int
case 1:		// float
case 2:		// string
this.value = m[1];
break;
case 3:		// unaryminus
this.first = new cr.expNode(owner_, m[1]);
break;
case 18:	// conditional
this.first = new cr.expNode(owner_, m[1]);
this.second = new cr.expNode(owner_, m[2]);
this.third = new cr.expNode(owner_, m[3]);
break;
case 19:	// system_exp
this.func = m[1];
;
this.results = [];
this.parameters = [];
if (m.length === 3)
{
paramsModel = m[2];
this.results.length = paramsModel.length + 1;	// must also fit 'ret'
}
else
this.results.length = 1;      // to fit 'ret'
break;
case 20:	// object_exp
this.object_type = this.runtime.types_by_index[m[1]];
;
this.beh_index = -1;
this.func = m[2];
if (m[3])
this.instance_expr = new cr.expNode(owner_, m[3]);
else
this.instance_expr = null;
this.results = [];
this.parameters = [];
if (m.length === 5)
{
paramsModel = m[4];
this.results.length = paramsModel.length + 1;
}
else
this.results.length = 1;	// to fit 'ret'
break;
case 21:		// instvar_exp
this.object_type = this.runtime.types_by_index[m[1]];
;
if (m[2])
this.instance_expr = new cr.expNode(owner_, m[2]);
else
this.instance_expr = null;
this.varindex = m[3];
break;
case 22:		// behavior_exp
this.object_type = this.runtime.types_by_index[m[1]];
;
this.behavior_type = this.object_type.getBehaviorByName(m[2]);
;
this.beh_index = this.object_type.getBehaviorIndexByName(m[2]);
this.func = m[3];
if (m[4])
this.instance_expr = new cr.expNode(owner_, m[4]);
else
this.instance_expr = null;
this.results = [];
this.parameters = [];
if (m.length === 6)
{
paramsModel = m[5];
this.results.length = paramsModel.length + 1;
}
else
this.results.length = 1;	// to fit 'ret'
break;
case 23:		// eventvar_exp
this.varname = m[1];
this.eventvar = null;	// assigned in postInit
break;
}
if (this.type >= 4 && this.type <= 17)
{
this.first = new cr.expNode(owner_, m[1]);
this.second = new cr.expNode(owner_, m[2]);
}
if (paramsModel)
{
var i, len;
for (i = 0, len = paramsModel.length; i < len; i++)
this.parameters.push(new cr.expNode(owner_, paramsModel[i]));
}
cr.seal(this);
};
var expNodeProto = cr.expNode.prototype;
expNodeProto.postInit = function ()
{
if (this.type === 23)	// eventvar_exp
{
this.eventvar = this.owner.runtime.getEventVariableByName(this.varname, this.owner.block.parent);
;
}
if (this.first)
this.first.postInit();
if (this.second)
this.second.postInit();
if (this.third)
this.third.postInit();
if (this.instance_expr)
this.instance_expr.postInit();
if (this.parameters)
{
var i, len;
for (i = 0, len = this.parameters.length; i < len; i++)
this.parameters[i].postInit();
}
};
expNodeProto.eval_system_exp = function (ret)
{
this.results[0] = ret;
var i, len;
for (i = 0, len = this.parameters.length; i < len; i++)
{
this.parameters[i].get(this.temp);
this.results[i + 1] = this.temp.data;   // passing actual javascript value as argument instead of expvalue
}
this.func.apply(this.runtime.system, this.results);
};
expNodeProto.eval_object_behavior_exp = function (ret)
{
var sol = this.object_type.getCurrentSol();
var instances = sol.getObjects();
if (!instances.length) {
ret.set_int(0);
return;
}
this.results[0] = ret;
var i, len;
for (i = 0, len = this.parameters.length; i < len; i++) {
this.parameters[i].get(this.temp);
this.results[i + 1] = this.temp.data;   // passing actual javascript value as argument instead of expvalue
}
var index = this.owner.solindex;
if (this.instance_expr) {
this.instance_expr.get(this.temp);
if (this.temp.is_number()) {
index = this.temp.data;
instances = this.object_type.instances;    // pick from all instances, not SOL
}
}
index %= instances.length;      // wraparound
if (index < 0)
index += instances.length;
var returned_val;
if (this.beh_index > -1)
returned_val = this.func.apply(instances[index].behavior_insts[this.beh_index], this.results);
else
returned_val = this.func.apply(instances[index], this.results);
;
};
expNodeProto.eval_instvar_exp = function (ret)
{
var sol = this.object_type.getCurrentSol();
var instances = sol.getObjects();
if (!instances.length)
{
ret.set_int(0);
return;
}
var index = this.owner.solindex;
if (this.instance_expr)
{
this.instance_expr.get(this.temp);
if (this.temp.is_number())
{
index = this.temp.data;
var type_instances = this.object_type.instances;
index %= type_instances.length;     // wraparound
if (index < 0)                      // offset
index += type_instances.length;
var to_ret = type_instances[index].instance_vars[this.varindex];
if (cr.is_string(to_ret))
ret.set_string(to_ret);
else
ret.set_float(to_ret);
return;         // done
}
}
index %= instances.length;      // wraparound
if (index < 0)
index += instances.length;
var to_ret = instances[index].instance_vars[this.varindex];
if (cr.is_string(to_ret))
ret.set_string(to_ret);
else
ret.set_float(to_ret);
};
expNodeProto.eval_int = function (ret)
{
ret.type = cr.exptype.Integer;
ret.data = this.value;
};
expNodeProto.eval_float = function (ret)
{
ret.type = cr.exptype.Float;
ret.data = this.value;
};
expNodeProto.eval_string = function (ret)
{
ret.type = cr.exptype.String;
ret.data = this.value;
};
expNodeProto.eval_unaryminus = function (ret)
{
this.first.get(ret);                // retrieve operand
if (ret.is_number())
ret.data = -ret.data;
};
expNodeProto.eval_add = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
if (ret.is_number() && this.temp.is_number())
{
ret.data += this.temp.data;          // both operands numbers: add
if (this.temp.is_float())
ret.make_float();
}
};
expNodeProto.eval_subtract = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
if (ret.is_number() && this.temp.is_number())
{
ret.data -= this.temp.data;          // both operands numbers: subtract
if (this.temp.is_float())
ret.make_float();
}
};
expNodeProto.eval_multiply = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
if (ret.is_number() && this.temp.is_number())
{
ret.data *= this.temp.data;          // both operands numbers: multiply
if (this.temp.is_float())
ret.make_float();
}
};
expNodeProto.eval_divide = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
if (ret.is_number() && this.temp.is_number())
{
ret.data /= this.temp.data;          // both operands numbers: divide
ret.make_float();
}
};
expNodeProto.eval_mod = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
if (ret.is_number() && this.temp.is_number())
{
ret.data %= this.temp.data;          // both operands numbers: modulo
if (this.temp.is_float())
ret.make_float();
}
};
expNodeProto.eval_power = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
if (ret.is_number() && this.temp.is_number())
{
ret.data = Math.pow(ret.data, this.temp.data);   // both operands numbers: raise to power
if (this.temp.is_float())
ret.make_float();
}
};
expNodeProto.eval_and = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
if (ret.is_number())
{
if (this.temp.is_string())
{
ret.set_string(ret.data.toString() + this.temp.data);
}
else
{
if (ret.data && this.temp.data)
ret.set_int(1);
else
ret.set_int(0);
}
}
else if (ret.is_string())
{
if (this.temp.is_string())
ret.data += this.temp.data;
else
{
ret.data += (Math.round(this.temp.data * 1e10) / 1e10).toString();
}
}
};
expNodeProto.eval_or = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
if (ret.is_number() && this.temp.is_number())
{
if (ret.data || this.temp.data)
ret.set_int(1);
else
ret.set_int(0);
}
};
expNodeProto.eval_conditional = function (ret)
{
this.first.get(ret);                // condition operand
if (ret.data)                       // is true
this.second.get(ret);           // evaluate second operand to ret
else
this.third.get(ret);            // evaluate third operand to ret
};
expNodeProto.eval_equal = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
ret.set_int(ret.data === this.temp.data ? 1 : 0);
};
expNodeProto.eval_notequal = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
ret.set_int(ret.data !== this.temp.data ? 1 : 0);
};
expNodeProto.eval_less = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
ret.set_int(ret.data < this.temp.data ? 1 : 0);
};
expNodeProto.eval_lessequal = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
ret.set_int(ret.data <= this.temp.data ? 1 : 0);
};
expNodeProto.eval_greater = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
ret.set_int(ret.data > this.temp.data ? 1 : 0);
};
expNodeProto.eval_greaterequal = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
ret.set_int(ret.data >= this.temp.data ? 1 : 0);
};
expNodeProto.eval_eventvar_exp = function (ret)
{
if (cr.is_number(this.eventvar.data))
ret.set_float(this.eventvar.data);
else
ret.set_string(this.eventvar.data);
};
cr.expvalue = function (type, data)
{
this.type = type || cr.exptype.Integer;
this.data = data || 0;
;
;
;
if (this.type == cr.exptype.Integer)
this.data = Math.floor(this.data);
cr.seal(this);
};
var expvalueProto = cr.expvalue.prototype;
expvalueProto.is_int = function ()
{
return this.type === cr.exptype.Integer;
};
expvalueProto.is_float = function ()
{
return this.type === cr.exptype.Float;
};
expvalueProto.is_number = function ()
{
return this.type === cr.exptype.Integer || this.type === cr.exptype.Float;
};
expvalueProto.is_string = function ()
{
return this.type === cr.exptype.String;
};
expvalueProto.make_int = function ()
{
if (!this.is_int())
{
if (this.is_float())
this.data = Math.floor(this.data);      // truncate float
else if (this.is_string())
this.data = parseInt(this.data, 10);
this.type = cr.exptype.Integer;
}
};
expvalueProto.make_float = function ()
{
if (!this.is_float())
{
if (this.is_string())
this.data = parseFloat(this.data);
this.type = cr.exptype.Float;
}
};
expvalueProto.make_string = function ()
{
if (!this.is_string())
{
this.data = this.data.toString();
this.type = cr.exptype.String;
}
};
expvalueProto.set_int = function (val)
{
;
this.type = cr.exptype.Integer;
this.data = Math.floor(val);
};
expvalueProto.set_float = function (val)
{
;
this.type = cr.exptype.Float;
this.data = val;
};
expvalueProto.set_string = function (val)
{
;
this.type = cr.exptype.String;
this.data = val;
};
expvalueProto.set_any = function (val)
{
if (cr.is_number(val))
{
this.type = cr.exptype.Float;
this.data = val;
}
else if (cr.is_string(val))
{
this.type = cr.exptype.String;
this.data = val.toString();
}
else
{
this.type = cr.exptype.Integer;
this.data = 0;
}
};
cr.exptype = {
Integer: 0,     // emulated; no native integer support in javascript
Float: 1,
String: 2
};
}());
;
cr.system_object = function (runtime)
{
this.runtime = runtime;
this.waits = [];
};
(function ()
{
var sysProto = cr.system_object.prototype;
sysProto.cnds = {};
sysProto.acts = {};
sysProto.exps = {};
var syscnds = sysProto.cnds;
syscnds.EveryTick = function()
{
return true;
};
syscnds.OnLayoutStart = function()
{
return true;
};
syscnds.OnLayoutEnd = function()
{
return true;
};
syscnds.Compare = function(x, cmp, y)
{
return cr.do_cmp(x, cmp, y);
};
syscnds.CompareTime = function (cmp, t)
{
var elapsed = this.runtime.kahanTime.sum;
if (cmp === 0)
{
var cnd = this.runtime.getCurrentCondition();
if (!cnd.extra.CompareTime_executed)
{
if (elapsed >= t)
{
cnd.extra.CompareTime_executed = true;
return true;
}
}
return false;
}
return cr.do_cmp(elapsed, cmp, t);
};
syscnds.LayerVisible = function (layer)
{
if (!layer)
return false;
else
return layer.visible;
};
syscnds.LayerCmpOpacity = function (layer, cmp, opacity_)
{
if (!layer)
return false;
return cr.do_cmp(layer.opacity * 100, cmp, opacity_);
};
syscnds.Repeat = function (count)
{
var current_frame = this.runtime.getCurrentEventStack();
var current_event = current_frame.current_event;
var solModifierAfterCnds = current_frame.isModifierAfterCnds();
var current_loop = this.runtime.pushLoopStack();
var i;
if (solModifierAfterCnds)
{
for (i = 0; i < count; i++)
{
this.runtime.pushCopySol(current_event.solModifiers);
current_loop.index = i;
current_event.retrigger();
this.runtime.popSol(current_event.solModifiers);
}
}
else
{
for (i = 0; i < count; i++)
{
current_loop.index = i;
current_event.retrigger();
}
}
this.runtime.popLoopStack();
return false;
};
syscnds.For = function (name, start, end)
{
var current_frame = this.runtime.getCurrentEventStack();
var current_event = current_frame.current_event;
var solModifierAfterCnds = current_frame.isModifierAfterCnds();
var current_loop = this.runtime.pushLoopStack(name);
var i;
if (solModifierAfterCnds)
{
for (i = start; i <= end; i++)  // inclusive to end
{
this.runtime.pushCopySol(current_event.solModifiers);
current_loop.index = i;
current_event.retrigger();
this.runtime.popSol(current_event.solModifiers);
}
}
else
{
for (i = start; i <= end; i++)  // inclusive to end
{
current_loop.index = i;
current_event.retrigger();
}
}
this.runtime.popLoopStack();
return false;
};
syscnds.ForEach = function (obj)
{
var sol = obj.getCurrentSol();
var instances = sol.getObjects().slice(0);
var current_frame = this.runtime.getCurrentEventStack();
var current_event = current_frame.current_event;
var solModifierAfterCnds = current_frame.isModifierAfterCnds();
var current_loop = this.runtime.pushLoopStack(name);
var i, len;
if (solModifierAfterCnds)
{
for (i = 0, len = instances.length; i < len; i++)
{
this.runtime.pushCopySol(current_event.solModifiers);
sol = obj.getCurrentSol();
sol.select_all = false;
sol.instances.length = 1;
sol.instances[0] = instances[i];
current_loop.index = i;
current_event.retrigger();
this.runtime.popSol(current_event.solModifiers);
}
}
else
{
sol.select_all = false;
sol.instances.length = 1;
for (i = 0, len = instances.length; i < len; i++)
{
sol.instances[0] = instances[i];
current_loop.index = i;
current_event.retrigger();
}
}
this.runtime.popLoopStack();
return false;
};
syscnds.TriggerOnce = function ()
{
var cnd = this.runtime.getCurrentCondition();
var last_tick = cnd.extra.TriggerOnce_lastTick || 0;
var cur_tick = this.runtime.tickcount;
cnd.extra.TriggerOnce_lastTick = cur_tick;
return this.runtime.layout_first_tick || !(last_tick === cur_tick - 1);
};
syscnds.Every = function (seconds)
{
var cnd = this.runtime.getCurrentCondition();
var last_time = cnd.extra.Every_lastTime || 0;
var cur_time = this.runtime.kahanTime.sum;
if (cur_time >= last_time + seconds)
{
cnd.extra.Every_lastTime = cur_time;
return true;
}
else
return false;
};
syscnds.PickNth = function (obj, index)
{
if (!obj)
return false;
var sol = obj.getCurrentSol();
var instances = sol.getObjects();
index = Math.floor(index);
if (index < 0 || index >= instances.length)
return false;
var inst = instances[index];
sol.select_all = false;
sol.instances.length = 1;
sol.instances[0] = inst;
return true;
};
syscnds.PickRandom = function (obj)
{
if (!obj)
return false;
var sol = obj.getCurrentSol();
var instances = sol.getObjects();
var index = Math.floor(Math.random() * instances.length);
if (index >= instances.length)
return false;
var inst = instances[index];
sol.select_all = false;
sol.instances.length = 1;
sol.instances[0] = inst;
return true;
};
syscnds.CompareVar = function (v, cmp, val)
{
return cr.do_cmp(v.data, cmp, val);
};
syscnds.IsGroupActive = function (group)
{
return this.runtime.activeGroups.hasOwnProperty(group.toLowerCase());
};
syscnds.IsPreview = function ()
{
return typeof cr_is_preview !== "undefined";
};
var sysacts = sysProto.acts;
sysacts.GoToLayout = function(to)
{
;
this.runtime.changelayout = to;
};
sysacts.CreateObject = function (obj, layer, x, y)
{
if (!layer || !obj)
return;
var inst = this.runtime.createInstance(obj, layer, x, y);
var sol = inst.type.getCurrentSol();
sol.select_all = false;
sol.instances.length = 1;
sol.instances[0] = inst;
};
sysacts.SetLayerVisible = function (layer, visible_)
{
if (!layer)
return;
if (layer.visible !== visible_)
{
layer.visible = visible_;
this.runtime.redraw = true;
}
};
sysacts.SetLayerOpacity = function (layer, opacity_)
{
if (!layer)
return;
opacity_ = cr.clamp(opacity_ / 100, 0, 1);
if (layer.opacity !== opacity_)
{
layer.opacity = opacity_;
this.runtime.redraw = true;
}
};
sysacts.SetLayerScaleRate = function (layer, sr)
{
if (!layer)
return;
if (layer.zoomRate !== sr)
{
layer.zoomRate = sr;
this.runtime.redraw = true;
}
};
sysacts.SetLayoutScale = function (s)
{
if (!this.runtime.running_layout)
return;
if (this.runtime.running_layout.scale !== s)
{
this.runtime.running_layout.scale = s;
this.runtime.redraw = true;
}
};
sysacts.ScrollX = function(x)
{
this.runtime.running_layout.scrollToX(x);
};
sysacts.ScrollY = function(y)
{
this.runtime.running_layout.scrollToY(y);
};
sysacts.Scroll = function(x, y)
{
this.runtime.running_layout.scrollToX(x);
this.runtime.running_layout.scrollToY(y);
};
sysacts.ScrollToObject = function(obj)
{
var inst = obj.getFirstPicked();
if (inst)
{
this.runtime.running_layout.scrollToX(inst.x);
this.runtime.running_layout.scrollToY(inst.y);
}
};
sysacts.SetVar = function(v, x)
{
if (v.vartype === 0)
{
if (cr.is_number(x))
v.data = x;
else
v.data = parseFloat(x);
}
else if (v.vartype === 1)
v.data = x.toString();
};
sysacts.AddVar = function(v, x)
{
if (v.vartype === 0)
{
if (cr.is_number(x))
v.data += x;
else
v.data += parseFloat(x);
}
else if (v.vartype === 1)
v.data += x.toString();
};
sysacts.SubVar = function(v, x)
{
if (v.vartype === 0)
{
if (cr.is_number(x))
v.data -= x;
else
v.data -= parseFloat(x);
}
};
sysacts.SetGroupActive = function (group, active)
{
var activeGroups = this.runtime.activeGroups;
group = group.toLowerCase();
switch (active) {
case 0:
delete activeGroups[group];
break;
case 1:
activeGroups[group] = true;
break;
case 2:
if (activeGroups[group])
delete activeGroups[group];
else
activeGroups[group] = true;
break;
}
};
sysacts.SetTimescale = function (ts_)
{
var ts = ts_;
if (ts < 0)
ts = 0;
this.runtime.timescale = ts;
};
sysacts.SetObjectTimescale = function (obj, ts_)
{
var ts = ts_;
if (ts < 0)
ts = 0;
if (!obj)
return;
var sol = obj.getCurrentSol();
var instances = sol.getObjects();
var i, len;
for (i = 0, len = instances.length; i < len; i++)
{
instances[i].my_timescale = ts;
}
};
sysacts.RestoreObjectTimescale = function (obj)
{
if (!obj)
return false;
var sol = obj.getCurrentSol();
var instances = sol.getObjects();
var i, len;
for (i = 0, len = instances.length; i < len; i++)
{
instances[i].my_timescale = -1.0;
}
};
sysacts.Wait = function (seconds)
{
if (seconds < 0)
return;
var i, len, s, t;
var evinfo = this.runtime.getCurrentEventStack();
var waitobj = {};
waitobj.time = this.runtime.kahanTime.sum + seconds;
waitobj.ev = evinfo.current_event;
waitobj.actindex = evinfo.actindex + 1;	// pointing at next action
waitobj.deleteme = false;
waitobj.sols = {};
waitobj.solModifiers = [];
for (i = 0, len = this.runtime.types_by_index.length; i < len; i++)
{
t = this.runtime.types_by_index[i];
s = t.getCurrentSol();
if (s.select_all)
continue;
waitobj.solModifiers.push(t);
waitobj.sols[i.toString()] = s.instances.slice(0);
}
this.waits.push(waitobj);
return true;
};
sysacts.SetLayerScale = function (layer, scale)
{
if (!layer)
return;
if (layer.scale === scale)
return;
layer.scale = scale;
this.runtime.redraw = true;
};
sysacts.ResetGlobals = function ()
{
var i, len, g;
for (i = 0, len = this.runtime.all_global_vars.length; i < len; i++)
{
g = this.runtime.all_global_vars[i];
g.data = g.initial;
}
};
sysacts.SetLayoutAngle = function (a)
{
a = cr.to_radians(a);
a = cr.clamp_angle(a);
if (this.runtime.running_layout)
{
if (this.runtime.running_layout.angle !== a)
{
this.runtime.running_layout.angle = a;
this.runtime.redraw = true;
}
}
};
sysacts.SetLayerAngle = function (layer, a)
{
if (!layer)
return;
a = cr.to_radians(a);
a = cr.clamp_angle(a);
if (layer.angle === a)
return;
layer.angle = a;
this.runtime.redraw = true;
};
var sysexps = sysProto.exps;
sysexps["int"] = function(ret, x)
{
if (cr.is_string(x))
{
ret.set_int(parseInt(x, 10));
if (isNaN(ret.data))
ret.data = 0;
}
else
ret.set_int(x);
};
sysexps["float"] = function(ret, x)
{
if (cr.is_string(x))
{
ret.set_float(parseFloat(x));
if (isNaN(ret.data))
ret.data = 0;
}
else
ret.set_float(x);
};
sysexps.str = function(ret, x)
{
if (cr.is_string(x))
ret.set_string(x);
else
ret.set_string(x.toString());
};
sysexps.len = function(ret, x)
{
ret.set_int(x.length || 0);
};
sysexps.random = function (ret, a, b)
{
if (b === undefined)
{
ret.set_float(Math.random() * a);
}
else
{
ret.set_float(Math.random() * (b - a) + a);
}
};
sysexps.sqrt = function(ret, x)
{
ret.set_float(Math.sqrt(x));
};
sysexps.abs = function(ret, x)
{
ret.set_float(Math.abs(x));
};
sysexps.round = function(ret, x)
{
ret.set_int(Math.round(x));
};
sysexps.floor = function(ret, x)
{
ret.set_int(Math.floor(x));
};
sysexps.ceil = function(ret, x)
{
ret.set_int(Math.ceil(x));
};
sysexps.sin = function(ret, x)
{
ret.set_float(Math.sin(cr.to_radians(x)));
};
sysexps.cos = function(ret, x)
{
ret.set_float(Math.cos(cr.to_radians(x)));
};
sysexps.tan = function(ret, x)
{
ret.set_float(Math.tan(cr.to_radians(x)));
};
sysexps.asin = function(ret, x)
{
ret.set_float(cr.to_degrees(Math.asin(x)));
};
sysexps.acos = function(ret, x)
{
ret.set_float(cr.to_degrees(Math.acos(x)));
};
sysexps.atan = function(ret, x)
{
ret.set_float(cr.to_degrees(Math.atan(x)));
};
sysexps.exp = function(ret, x)
{
ret.set_float(Math.exp(x));
};
sysexps.ln = function(ret, x)
{
ret.set_float(Math.log(x));
};
sysexps.log10 = function(ret, x)
{
ret.set_float(Math.log(x) / Math.LN10);
};
sysexps.max = function(ret)
{
var max_ = arguments[1];
var i, len;
for (i = 2, len = arguments.length; i < len; i++)
{
if (max_ < arguments[i])
max_ = arguments[i];
}
ret.set_float(max_);
};
sysexps.min = function(ret)
{
var min_ = arguments[1];
var i, len;
for (i = 2, len = arguments.length; i < len; i++)
{
if (min_ > arguments[i])
min_ = arguments[i];
}
ret.set_float(min_);
};
sysexps.dt = function(ret)
{
ret.set_float(this.runtime.dt);
};
sysexps.timescale = function(ret)
{
ret.set_float(this.runtime.timescale);
};
sysexps.wallclocktime = function(ret)
{
ret.set_float((Date.now() - this.runtime.start_time) / 1000.0);
};
sysexps.time = function(ret)
{
ret.set_float(this.runtime.kahanTime.sum);
};
sysexps.tickcount = function(ret)
{
ret.set_int(this.runtime.tickcount);
};
sysexps.objectcount = function(ret)
{
ret.set_int(this.runtime.objectcount);
};
sysexps.fps = function(ret)
{
ret.set_int(this.runtime.fps);
};
sysexps.loopindex = function(ret, name_)
{
if (!this.runtime.loop_stack.length)
{
ret.set_int(0);
return;
}
if (name_)
{
var i, len;
for (i = 0, len = this.runtime.loop_stack.length; i < len; i++)
{
var loop = this.runtime.loop_stack[i];
if (loop.name === name_)
{
ret.set_int(loop.index);
return;
}
}
ret.set_int(0);
}
else
{
ret.set_int(this.runtime.getCurrentLoop().index);
}
};
sysexps.distance = function(ret, x1, y1, x2, y2)
{
ret.set_float(cr.distanceTo(x1, y1, x2, y2));
};
sysexps.angle = function(ret, x1, y1, x2, y2)
{
ret.set_float(cr.to_degrees(cr.angleTo(x1, y1, x2, y2)));
};
sysexps.scrollx = function(ret)
{
ret.set_float(this.runtime.running_layout.scrollX);
};
sysexps.scrolly = function(ret)
{
ret.set_float(this.runtime.running_layout.scrollY);
};
sysexps.newline = function(ret)
{
ret.set_string("\n");
};
sysexps.lerp = function(ret, a, b, x)
{
ret.set_float(cr.lerp(a, b, x));
};
sysexps.windowwidth = function(ret)
{
ret.set_int(this.runtime.width);
};
sysexps.windowheight = function(ret)
{
ret.set_int(this.runtime.height);
};
sysexps.uppercase = function(ret, str)
{
ret.set_string(str.toUpperCase());
};
sysexps.lowercase = function(ret, str)
{
ret.set_string(str.toLowerCase());
};
sysexps.clamp = function(ret, x, l, u)
{
if (x < l)
ret.set_float(l);
else if (x > u)
ret.set_float(u);
else
ret.set_float(x);
};
sysexps.layerscale = function (ret, layerparam)
{
var layer = this.runtime.getLayer(layerparam);
if (!layer)
ret.set_float(0);
else
ret.set_float(layer.scale);
};
sysexps.layeropacity = function (ret, layerparam)
{
var layer = this.runtime.getLayer(layerparam);
if (!layer)
ret.set_float(0);
else
ret.set_float(layer.opacity * 100);
};
sysexps.layerscalerate = function (ret, layerparam)
{
var layer = this.runtime.getLayer(layerparam);
if (!layer)
ret.set_float(0);
else
ret.set_float(layer.zoomRate);
};
sysexps.layoutscale = function (ret)
{
if (this.runtime.running_layout)
ret.set_float(this.runtime.running_layout.scale);
else
ret.set_float(0);
};
sysexps.layoutwidth = function (ret)
{
ret.set_int(this.runtime.running_layout.width);
};
sysexps.layoutheight = function (ret)
{
ret.set_int(this.runtime.running_layout.height);
};
sysexps.find = function (ret, text, searchstr)
{
ret.set_int(text.search(new RegExp(cr.regexp_escape(searchstr), "i")));
};
sysexps.left = function (ret, text, n)
{
ret.set_string(text.substr(0, n));
};
sysexps.right = function (ret, text, n)
{
ret.set_string(text.substr(text.length - n));
};
sysexps.mid = function (ret, text, index_, length_)
{
ret.set_string(text.substr(index_, length_));
};
sysexps.tokenat = function (ret, text, index_, sep)
{
var arr = text.split(sep);
var i = Math.floor(index_);
if (i < 0 || i >= arr.length)
ret.set_string("");
else
ret.set_string(arr[i]);
};
sysexps.tokencount = function (ret, text, sep)
{
ret.set_int(text.split(sep).length);
};
sysexps.replace = function (ret, text, find_, replace_)
{
ret.set_string(text.replace(new RegExp(cr.regexp_escape(find_), "gi"), replace_));
};
sysexps.trim = function (ret, text)
{
ret.set_string(text.trim());
};
sysexps.pi = function (ret)
{
ret.set_float(Math.PI);
};
sysexps.layoutname = function (ret)
{
if (this.runtime.running_layout)
ret.set_string(this.runtime.running_layout.name);
else
ret.set_string("");
};
sysexps.renderer = function (ret)
{
ret.set_string(this.runtime.gl ? "webgl" : "canvas2d");
};
sysProto.runWaits = function ()
{
var i, j, len, w, k, s;
var evinfo = this.runtime.getCurrentEventStack();
for (i = 0, len = this.waits.length; i < len; i++)
{
w = this.waits[i];
if (w.time > this.runtime.kahanTime.sum)
continue;
evinfo.current_event = w.ev;
evinfo.actindex = w.actindex;
evinfo.cndindex = 0;
for (k in w.sols)
{
if (w.sols.hasOwnProperty(k))
{
s = this.runtime.types_by_index[parseInt(k, 10)].getCurrentSol();
s.select_all = false;
s.instances = w.sols[k];
}
}
w.ev.resume_actions_and_subevents();
this.runtime.clearSol(w.solModifiers);
w.deleteme = true;
}
for (i = 0, j = 0, len = this.waits.length; i < len; i++)
{
w = this.waits[i];
this.waits[j] = w;
if (!w.deleteme)
j++;
}
this.waits.length = j;
};
}());
;
cr.add_common_aces = function (m)
{
var pluginProto = m[0].prototype;	
var singleglobal = m[1];
var is_world = m[2];
var position_aces = m[3];
var size_aces = m[4];
var angle_aces = m[5];
var appearance_aces = m[6];
var zorder_aces = m[7];
if (!pluginProto.cnds)
pluginProto.cnds = {};
if (!pluginProto.acts)
pluginProto.acts = {};
if (!pluginProto.exps)
pluginProto.exps = {};
var cnds = pluginProto.cnds;
var acts = pluginProto.acts;
var exps = pluginProto.exps;
if (position_aces)
{
cnds.CompareX = function (cmp, x)
{
return cr.do_cmp(this.x, cmp, x);
};
cnds.CompareY = function (cmp, y)
{
return cr.do_cmp(this.y, cmp, y);
};
cnds.IsOnScreen = function ()
{
var layer = this.layer;				
this.update_bbox();
var bbox = this.bbox;
return !(bbox.right < layer.viewLeft || bbox.bottom < layer.viewTop || bbox.left > layer.viewRight || bbox.top > layer.viewBottom);
};
cnds.IsOutsideLayout = function ()
{
this.update_bbox();
var bbox = this.bbox;
var layout = this.runtime.running_layout;
return (bbox.right < 0 || bbox.bottom < 0 || bbox.left > layout.width || bbox.top > layout.height);
};
cnds.PickDistance = function (which, x, y)
{
var sol = this.getCurrentSol();
var instances = sol.getObjects();
if (!instances.length)
return false;
var inst = instances[0];
var pickme = inst;
var dist = cr.distanceTo(inst.x, inst.y, x, y);
var i, len, d;
for (i = 1, len = instances.length; i < len; i++)
{
inst = instances[i];
d = cr.distanceTo(inst.x, inst.y, x, y);
if ((which === 0 && d < dist) || (which === 1 && d > dist))
{
dist = d;
pickme = inst;
}
}
sol.select_all = false;
sol.instances.length = 1;
sol.instances[0] = pickme;
return true;
};
acts.SetX = function (x)
{
if (this.x !== x)
{
this.x = x;
this.set_bbox_changed();
}
};
acts.SetY = function (y)
{
if (this.y !== y)
{
this.y = y;
this.set_bbox_changed();
}
};
acts.SetPos = function (x, y)
{
if (this.x !== x || this.y !== y)
{
this.x = x;
this.y = y;
this.set_bbox_changed();
}
};
acts.SetPosToObject = function (obj, imgpt)
{
var inst = obj.getPairedInstance(this);
if (!inst)
return;
var newx, newy;
if (inst.getImagePoint)
{
newx = inst.getImagePoint(imgpt, true);
newy = inst.getImagePoint(imgpt, false);
}
else
{
newx = inst.x;
newy = inst.y;
}
if (this.x !== newx || this.y !== newy)
{
this.x = newx;
this.y = newy;
this.set_bbox_changed();
}
};
acts.MoveForward = function (dist)
{
if (dist !== 0)
{
this.x += Math.cos(this.angle) * dist;
this.y += Math.sin(this.angle) * dist;
this.set_bbox_changed();
}
};
acts.MoveAtAngle = function (a, dist)
{
if (dist !== 0)
{
this.x += Math.cos(cr.to_radians(a)) * dist;
this.y += Math.sin(cr.to_radians(a)) * dist;
this.set_bbox_changed();
}
};
exps.X = function (ret)
{
ret.set_float(this.x);
};
exps.Y = function (ret)
{
ret.set_float(this.y);
};
exps.dt = function (ret)
{
ret.set_float(this.runtime.getDt(this));
};
}
if (size_aces)
{
cnds.CompareWidth = function (cmp, w)
{
return cr.do_cmp(this.width, cmp, w);
};
cnds.CompareHeight = function (cmp, h)
{
return cr.do_cmp(this.height, cmp, h);
};
acts.SetWidth = function (w)
{
var newwidth = w;
if (newwidth < 0)
newwidth = -newwidth;
if (this.width !== newwidth)
{
this.width = newwidth;
this.set_bbox_changed();
}
};
acts.SetHeight = function (h)
{
var newheight = h;
if (newheight < 0)
newheight = -newheight;
if (this.height !== newheight)
{
this.height = newheight;
this.set_bbox_changed();
}
};
acts.SetSize = function (w, h)
{
var newwidth = w;
var newheight = h;
if (newwidth < 0)
newwidth = -newwidth;
if (newheight < 0)
newheight = -newheight;
if (this.width !== newwidth || this.height !== newheight)
{
this.width = newwidth;
this.height = newheight;
this.set_bbox_changed();
}
};
exps.Width = function (ret)
{
ret.set_float(this.width);
};
exps.Height = function (ret)
{
ret.set_float(this.height);
};
}
if (angle_aces)
{
cnds.AngleWithin = function (within, a)
{
return cr.angleDiff(this.angle, cr.to_radians(a)) <= cr.to_radians(within);
};
cnds.IsClockwiseFrom = function (a)
{
return cr.angleClockwise(this.angle, cr.to_radians(a));
};
cnds.IsBetweenAngles = function (a, b)
{
var lower = cr.to_clamped_radians(a);
var upper = cr.to_clamped_radians(b);
var angle = cr.clamp_angle(this.angle);
return cr.angleClockwise(angle, lower) && !cr.angleClockwise(angle, upper);
};
acts.SetAngle = function (a)
{
var newangle = cr.to_radians(cr.clamp_angle_degrees(a));
if (isNaN(newangle))
return;
if (this.angle !== newangle)
{
this.angle = newangle;
this.set_bbox_changed();
}
};
acts.RotateClockwise = function (a)
{
if (a !== 0 && !isNaN(a))
{
this.angle += cr.to_radians(a);
this.angle = cr.clamp_angle(this.angle);
this.set_bbox_changed();
}
};
acts.RotateCounterclockwise = function (a)
{
if (a !== 0 && !isNaN(a))
{
this.angle -= cr.to_radians(a);
this.angle = cr.clamp_angle(this.angle);
this.set_bbox_changed();
}
};
acts.RotateTowardAngle = function (amt, target)
{
var newangle = cr.angleRotate(this.angle, cr.to_radians(target), cr.to_radians(amt));
if (isNaN(newangle))
return;
if (this.angle !== newangle)
{
this.angle = newangle;
this.set_bbox_changed();
}
};
acts.RotateTowardPosition = function (amt, x, y)
{
var dx = x - this.x;
var dy = y - this.y;
var target = Math.atan2(dy, dx);
var newangle = cr.angleRotate(this.angle, target, cr.to_radians(amt));
if (isNaN(newangle))
return;
if (this.angle !== newangle)
{
this.angle = newangle;
this.set_bbox_changed();
}
};
acts.SetTowardPosition = function (x, y)
{
var dx = x - this.x;
var dy = y - this.y;
var newangle = Math.atan2(dy, dx);
if (isNaN(newangle))
return;
if (this.angle !== newangle)
{
this.angle = newangle;
this.set_bbox_changed();
}
};
exps.Angle = function (ret)
{
ret.set_float(cr.to_clamped_degrees(this.angle));
};
}
if (!singleglobal)
{
cnds.CompareInstanceVar = function (iv, cmp, val)
{
return cr.do_cmp(this.instance_vars[iv], cmp, val);
};
cnds.IsBoolInstanceVarSet = function (iv)
{
return this.instance_vars[iv];
};
cnds.PickByUID = function (u)
{
return this.uid === u;
};
acts.SetInstanceVar = function (iv, val)
{
if (cr.is_number(this.instance_vars[iv]))
{
if (cr.is_number(val))
this.instance_vars[iv] = val;
else
this.instance_vars[iv] = parseFloat(val);
}
else if (cr.is_string(this.instance_vars[iv]))
{
if (cr.is_string(val))
this.instance_vars[iv] = val;
else
this.instance_vars[iv] = val.toString();
}
else
;
};
acts.AddInstanceVar = function (iv, val)
{
if (cr.is_number(this.instance_vars[iv]))
{
if (cr.is_number(val))
this.instance_vars[iv] += val;
else
this.instance_vars[iv] += parseFloat(val);
}
else if (cr.is_string(this.instance_vars[iv]))
{
if (cr.is_string(val))
this.instance_vars[iv] += val;
else
this.instance_vars[iv] += val.toString();
}
else
;
};
acts.SubInstanceVar = function (iv, val)
{
if (cr.is_number(this.instance_vars[iv]))
{
if (cr.is_number(val))
this.instance_vars[iv] -= val;
else
this.instance_vars[iv] -= parseFloat(val);
}
else
;
};
acts.SetBoolInstanceVar = function (iv, val)
{
this.instance_vars[iv] = val ? 1 : 0;
};
acts.ToggleBoolInstanceVar = function (iv)
{
this.instance_vars[iv] = 1 - this.instance_vars[iv];
};
acts.Destroy = function ()
{
this.runtime.DestroyInstance(this);
};
exps.Count = function (ret)
{
ret.set_int(this.type.instances.length);
};
exps.UID = function (ret)
{
ret.set_int(this.uid);
};
}
if (appearance_aces)
{
cnds.IsVisible = function ()
{
return this.visible;
};
acts.SetVisible = function (v)
{
if (!v !== !this.visible)
{
this.visible = v;
this.runtime.redraw = true;
}
};
cnds.CompareOpacity = function (cmp, x)
{
return cr.do_cmp(this.opacity * 100, cmp, x);
};
acts.SetOpacity = function (x)
{
var new_opacity = x / 100.0;
if (new_opacity < 0)
new_opacity = 0;
else if (new_opacity > 1)
new_opacity = 1;
if (new_opacity !== this.opacity)
{
this.opacity = new_opacity;
this.runtime.redraw = true;
}
};
exps.Opacity = function (ret)
{
ret.set_float(this.opacity * 100.0);
};
}
if (zorder_aces)
{
cnds.IsOnLayer = function (layer_)
{
if (!layer_)
return false;
return this.layer === layer_;
};
acts.MoveToTop = function ()
{
var zindex = this.get_zindex();
if (zindex === this.layer.instances.length - 1)
return;
cr.arrayRemove(this.layer.instances, zindex);
this.layer.instances.push(this);
this.runtime.redraw = true;
this.layer.zindices_stale = true;
};
acts.MoveToBottom = function ()
{
var zindex = this.get_zindex();
if (zindex === 0)
return;
cr.arrayRemove(this.layer.instances, zindex);
this.layer.instances.unshift(this);
this.runtime.redraw = true;
this.layer.zindices_stale = true;
};
acts.MoveToLayer = function (layerMove)
{
if (!layerMove || layerMove == this.layer)
return;
cr.arrayRemove(this.layer.instances, this.get_zindex());
this.layer.zindices_stale = true;
this.layer = layerMove;
this.zindex = layerMove.instances.length;
layerMove.instances.push(this);
this.runtime.redraw = true;
};
exps.LayerNumber = function (ret)
{
ret.set_int(this.layer.number);
};
exps.LayerName = function (ret)
{
ret.set_string(this.layer.name);
};
exps.ZIndex = function (ret)
{
ret.set_int(this.get_zindex());
};
}
};
cr.set_bbox_changed = function ()
{
this.bbox_changed = true;       // will recreate next time box requested
this.runtime.redraw = true;     // assume runtime needs to redraw
var i, len;
for (i = 0, len = this.bbox_changed_callbacks.length; i < len; i++)
{
this.bbox_changed_callbacks[i](this);
}
};
cr.add_bbox_changed_callback = function (f)
{
if (f)
this.bbox_changed_callbacks.push(f);
};
cr.update_bbox = function ()
{
if (!this.bbox_changed)
return;                 // bounding box not changed
this.bbox.set(this.x, this.y, this.x + this.width, this.y + this.height);
this.bbox.offset(-this.hotspotX * this.width, -this.hotspotY * this.height);
if (!this.angle || this.angle === 0)
{
this.bquad.set_from_rect(this.bbox);    // make bounding quad from box
}
else
{
this.bbox.offset(-this.x, -this.y);       					// translate to origin
this.bquad.set_from_rotated_rect(this.bbox, this.angle);	// rotate around origin
this.bquad.offset(this.x, this.y);      					// translate back to original position
this.bquad.bounding_box(this.bbox);
}
var temp = 0;
if (this.bbox.left > this.bbox.right)
{
temp = this.bbox.left;
this.bbox.left = this.bbox.right;
this.bbox.right = temp;
}
if (this.bbox.top > this.bbox.bottom)
{
temp = this.bbox.top;
this.bbox.top = this.bbox.bottom;
this.bbox.bottom = temp;
}
this.bbox_changed = false;  // bounding box up to date
};
cr.inst_contains_pt = function (x, y)
{
if (!this.bbox.contains_pt(x, y))
return false;
if (!this.bquad.contains_pt(x, y))
return false;
if (this.collision_poly && !this.collision_poly.is_empty())
{
this.collision_poly.cache_poly(this.width, this.height, this.angle);
return this.collision_poly.contains_pt(x - this.x, y - this.y);
}
else
return true;
};
cr.inst_get_iid = function ()
{
this.type.updateIIDs();
return this.iid;
};
cr.inst_get_zindex = function ()
{
this.layer.updateZIndices();
return this.zindex;
};
cr.inst_toString = function ()
{
return "inst:" + this.type.name + "#" + this.uid;
};
cr.type_getFirstPicked = function ()
{
var instances = this.getCurrentSol().getObjects();
if (instances.length)
return instances[0];
else
return null;
};
cr.type_getPairedInstance = function (inst)
{
var instances = this.getCurrentSol().getObjects();
if (instances.length)
return instances[inst.get_iid() % instances.length];
else
return null;
};
cr.type_updateIIDs = function ()
{
if (!this.stale_iids)
return;		// up to date
var i, len;
for (i = 0, len = this.instances.length; i < len; i++)
this.instances[i].iid = i;
this.stale_iids = false;
};
cr.type_getCurrentSol = function ()
{
return this.solstack[this.cur_sol];
};
cr.type_pushCleanSol = function ()
{
this.cur_sol++;
if (this.cur_sol === this.solstack.length)
this.solstack.push(new cr.selection(this));
else
this.solstack[this.cur_sol].select_all = true;  // else clear next SOL
};
cr.type_pushCopySol = function ()
{
this.cur_sol++;
if (this.cur_sol === this.solstack.length)
this.solstack.push(new cr.selection(this));
var clonesol = this.solstack[this.cur_sol];
var prevsol = this.solstack[this.cur_sol - 1];
if (prevsol.select_all)
clonesol.select_all = true;
else
{
clonesol.select_all = false;
clonesol.instances = prevsol.instances.slice(0);    // copy elements
}
};
cr.type_popSol = function ()
{
;
this.cur_sol--;
};
cr.type_getBehaviorByName = function (behname) {
var i, len;
for (i = 0, len = this.behaviors.length; i < len; i++) {
if (behname === this.behaviors[i].name)
return this.behaviors[i];
}
return null;
};
cr.type_getBehaviorIndexByName = function (behname) {
var i, len;
for (i = 0, len = this.behaviors.length; i < len; i++) {
if (behname === this.behaviors[i].name)
return i;
}
return -1;
};
cr.do_cmp = function (x, cmp, y)
{
switch (cmp)
{
case 0:     // equal
return x === y;
case 1:     // not equal
return x !== y;
case 2:     // less
return x < y;
case 3:     // less/equal
return x <= y;
case 4:     // greater
return x > y;
case 5:     // greater/equal
return x >= y;
default:
;
return false;
}
};
;
;
cr.plugins_.Audio = function(runtime)
{
this.runtime = runtime;
};
(function ()
{
var pluginProto = cr.plugins_.Audio.prototype;
pluginProto.Type = function(plugin)
{
this.plugin = plugin;
this.runtime = plugin.runtime;
};
var typeProto = pluginProto.Type.prototype;
typeProto.onCreate = function()
{
};
var audRuntime = null;
var audInst = null;
var audTag = "";
var API_HTML5 = 0;
var API_WEBAUDIO = 1;
var API_PHONEGAP = 2;
var api = API_HTML5;
var context = null;
var audioBuffers = [];		// cache of buffers
var audioInstances = [];	// cache of instances
var lastAudio = null;
var useOgg = !!(new Audio().canPlayType('audio/ogg; codecs="vorbis"'));
var timescale_mode = 0;
var C2AudioBuffer = function (src_, is_music)
{
this.src = src_;
this.myapi = api;
this.is_music = is_music;
if (api === API_WEBAUDIO && is_music)
this.myapi = API_HTML5;
this.bufferObject = null;
var request;
switch (this.myapi) {
case API_HTML5:
this.bufferObject = new Audio();
this.bufferObject.autoplay = false;	// this is only a source buffer, not an instance
this.bufferObject.preload = "auto";
this.bufferObject.src = src_;
break;
case API_WEBAUDIO:
request = new XMLHttpRequest();
request.open("GET", src_, true);
request.responseType = "arraybuffer";
request.onload = (function (self) { return function () {
context["decodeAudioData"](request.response, function (buffer) {
self.bufferObject = buffer;
if (!cr.is_undefined(self.playTagWhenReady))
{
var a = new C2AudioInstance(self, self.playTagWhenReady);
a.play();
audioInstances.push(a);
}
});
}; })(this);
request.send();
break;
case API_PHONEGAP:
this.bufferObject = new Media(src_);
break;
}
};
var C2AudioInstance = function (buffer_, tag_)
{
this.tag = tag_;
this.fresh = true;
this.stopped = true;
this.src = buffer_.src;
this.buffer = buffer_;
this.myapi = buffer_.myapi;
this.is_music = buffer_.is_music;
this.playbackRate = 1;
this.volume = 1;
this.mutevol = 1;
this.startTime = audRuntime.kahanTime.sum;
this.instanceObject = null;
switch (this.myapi) {
case API_HTML5:
this.instanceObject = new Audio();
this.instanceObject.autoplay = false;
this.instanceObject.src = buffer_.bufferObject.src;
this.instanceObject.addEventListener('ended', (function (self) {
return function () {
audTag = self.tag;
self.stopped = true;
audRuntime.trigger(cr.plugins_.Audio.prototype.cnds.OnEnded, audInst);
};
})(this));
break;
case API_WEBAUDIO:
if (buffer_.bufferObject)
{
this.instanceObject = context["createBufferSource"]();
this.instanceObject["buffer"] = buffer_.bufferObject;
this.instanceObject["connect"](context["destination"]);
}
break;
case API_PHONEGAP:
this.instanceObject = new Media(buffer_.src);
break;
}
};
C2AudioInstance.prototype.hasEnded = function ()
{
switch (this.myapi) {
case API_HTML5:
return this.instanceObject.ended;
case API_WEBAUDIO:
if (!this.fresh && !this.stopped && this.instanceObject["loop"])
return false;
return (audRuntime.kahanTime.sum - this.startTime) > this.buffer.bufferObject["duration"];
case API_PHONEGAP:
return (audRuntime.kahanTime.sum - this.startTime) > this.buffer.bufferObject.getDuration();
}
return true;
};
C2AudioInstance.prototype.canBeRecycled = function ()
{
if (this.fresh || this.stopped)
return true;		// not yet used or is not playing
return this.hasEnded();
};
C2AudioInstance.prototype.play = function ()
{
switch (this.myapi) {
case API_HTML5:
this.instanceObject.playbackRate = 1.0;
this.instanceObject.volume = 1.0;
this.instanceObject.loop = false;
this.instanceObject.muted = false;
if (!this.fresh && this.stopped)
this.instanceObject.currentTime = 0;
this.instanceObject.play();
break;
case API_WEBAUDIO:
this.muted = false;
this.volume = 1;
if (!this.fresh)
{
this.instanceObject = context["createBufferSource"]();
this.instanceObject["buffer"] = this.buffer.bufferObject;
this.instanceObject["connect"](context["destination"]);
}
this.instanceObject["noteOn"](0);
break;
case API_PHONEGAP:
if (!this.fresh && this.stopped)
this.instanceObject["seekTo"](0);
this.instanceObject.play(); 
break;
}
this.playbackRate = 1;
this.startTime = audRuntime.kahanTime.sum;
this.fresh = false;
this.stopped = false;
};
C2AudioInstance.prototype.stop = function ()
{
switch (this.myapi) {
case API_HTML5:
this.instanceObject.pause();
break;
case API_WEBAUDIO:
this.instanceObject["noteOff"](0);
break;
case API_PHONEGAP:
this.instanceObject["stop"](); 
break;
}
this.stopped = true;
};
C2AudioInstance.prototype.setVolume = function (v)
{
switch (this.myapi) {
case API_HTML5:
if (this.instanceObject.volume)		// ff 3.6 doesn't seem to have this property
this.instanceObject.volume = v;
break;
case API_WEBAUDIO:
this.volume = v;
this.instanceObject["gain"]["value"] = v * this.mutevol;
break;
case API_PHONEGAP:
break;
}
};
C2AudioInstance.prototype.setMuted = function (m)
{
switch (this.myapi) {
case API_HTML5:
this.instanceObject.muted = !!m;
break;
case API_WEBAUDIO:
this.mutevol = (m ? 0 : 1);
this.instanceObject["gain"]["value"] = this.volume * this.mutevol;
break;
case API_PHONEGAP:
break;
}
};
C2AudioInstance.prototype.setLooping = function (l)
{
switch (this.myapi) {
case API_HTML5:
this.instanceObject.loop = !!l;
break;
case API_WEBAUDIO:
this.instanceObject.loop = !!l
break;
case API_PHONEGAP:
break;
}
};
C2AudioInstance.prototype.setPlaybackRate = function (r)
{
this.playbackRate = r;
this.updatePlaybackRate();
};
C2AudioInstance.prototype.updatePlaybackRate = function ()
{
var r = this.playbackRate;
if ((timescale_mode === 1 && !this.is_music) || timescale_mode === 2)
r *= audRuntime.timescale;
switch (this.myapi) {
case API_HTML5:
if (this.instanceObject.playbackRate !== r)
this.instanceObject.playbackRate = r;
break;
case API_WEBAUDIO:
if (this.instanceObject["playbackRate"]["value"] !== r)
this.instanceObject["playbackRate"]["value"] = r;
break;
case API_PHONEGAP:
break;
}
};
pluginProto.Instance = function(type)
{
this.type = type;
this.runtime = type.runtime;
audRuntime = this.runtime;
audInst = this;
context = null;
if (typeof AudioContext !== "undefined")
{
api = API_WEBAUDIO;
context = new AudioContext();
}
else if (typeof webkitAudioContext !== "undefined")
{
api = API_WEBAUDIO;
context = new webkitAudioContext();
}
if (api !== API_WEBAUDIO && this.runtime.isPhoneGap)
api = API_PHONEGAP;
switch (api) {
case API_HTML5:
;
break;
case API_WEBAUDIO:
;
break;
case API_PHONEGAP:
;
break;
default:
;
}
this.runtime.tickMe(this);
};
var instanceProto = pluginProto.Instance.prototype;
instanceProto.onCreate = function ()
{
timescale_mode = this.properties[0];	// 0 = off, 1 = sounds only, 2 = all
};
instanceProto.tick = function ()
{
var i, len, a;
for (i = 0, len = audioInstances.length; i < len; i++)
{
a = audioInstances[i];
if (api !== API_HTML5)
{
if (!a.fresh && !a.stopped && a.hasEnded())
{
a.stopped = true;
audTag = a.tag;
audRuntime.trigger(cr.plugins_.Audio.prototype.cnds.OnEnded, audInst);
}
}
if (timescale_mode !== 0)
a.updatePlaybackRate();
}
};
instanceProto.getAudioBuffer = function (src_, is_music)
{
var i, len, a;
for (i = 0, len = audioBuffers.length; i < len; i++)
{
a = audioBuffers[i];
if (a.src === src_)
return a;
}
a = new C2AudioBuffer(src_, is_music);
audioBuffers.push(a);
return a;
};
instanceProto.getAudioInstance = function (src_, tag, is_music)
{
var i, len, a;
for (i = 0, len = audioInstances.length; i < len; i++)
{
a = audioInstances[i];
if (a.src === src_ && a.canBeRecycled())
{
a.tag = tag;
return a;
}
}
var b = this.getAudioBuffer(src_, is_music);
if (!b.bufferObject)
{
if (tag !== "<preload>")
b.playTagWhenReady = tag;
return null;
}
a = new C2AudioInstance(b, tag);
audioInstances.push(a);
return a;
};
var taggedAudio = [];
instanceProto.getAudioByTag = function (tag)
{
taggedAudio.length = 0;
if (!tag.length)
{
if (!lastAudio || lastAudio.hasEnded())
return;
else
{
taggedAudio.length = 1;
taggedAudio[0] = lastAudio;
return;
}
}
var i, len, a;
for (i = 0, len = audioInstances.length; i < len; i++)
{
a = audioInstances[i];
if (tag.toLowerCase() === a.tag.toLowerCase())
taggedAudio.push(a);
}
};
pluginProto.cnds = {};
var cnds = pluginProto.cnds;
cnds.OnEnded = function (t)
{
return audTag.toLowerCase() === t.toLowerCase();
};
pluginProto.acts = {};
var acts = pluginProto.acts;
acts.Play = function (file, tag)
{
var is_music = file[1];
var src = this.runtime.files_subfolder + file[0] + (useOgg ? ".ogg" : ".m4a");
lastAudio = this.getAudioInstance(src, tag, is_music);
if (!lastAudio)
return;
lastAudio.play();
};
acts.SetLooping = function (tag, looping)
{
this.getAudioByTag(tag);
var i, len;
for (i = 0, len = taggedAudio.length; i < len; i++)
taggedAudio[i].setLooping(looping === 0);
};
acts.SetMuted = function (tag, muted)
{
this.getAudioByTag(tag);
var i, len;
for (i = 0, len = taggedAudio.length; i < len; i++)
taggedAudio[i].setMuted(muted === 0);
};
acts.SetVolume = function (tag, vol)
{
this.getAudioByTag(tag);
var v = Math.pow(10, vol / 20);
if (v < 0)
v = 0;
if (v > 1)
v = 1;
var i, len;
for (i = 0, len = taggedAudio.length; i < len; i++)
taggedAudio[i].setVolume(v);
};
acts.Preload = function (file)
{
var is_music = file[1];
var src = this.runtime.files_subfolder + file[0] + (useOgg ? ".ogg" : ".m4a");
this.getAudioInstance(src, "<preload>", is_music);
};
acts.SetPlaybackRate = function (tag, rate)
{
this.getAudioByTag(tag);
if (rate < 0.0)
rate = 0;
var i, len;
for (i = 0, len = taggedAudio.length; i < len; i++)
taggedAudio[i].setPlaybackRate(rate);
};
acts.Stop = function (tag)
{
this.getAudioByTag(tag);
var i, len;
for (i = 0, len = taggedAudio.length; i < len; i++)
taggedAudio[i].stop();
};
pluginProto.exps = {};
var exps = pluginProto.exps;
}());
;
;
cr.plugins_.Keyboard = function(runtime)
{
this.runtime = runtime;
};
(function ()
{
var pluginProto = cr.plugins_.Keyboard.prototype;
pluginProto.Type = function(plugin)
{
this.plugin = plugin;
this.runtime = plugin.runtime;
};
var typeProto = pluginProto.Type.prototype;
typeProto.onCreate = function()
{
};
pluginProto.Instance = function(type)
{
this.type = type;
this.runtime = type.runtime;
this.keyMap = new Array(256);	// stores key up/down state
this.usedKeys = new Array(256);
this.triggerKey = 0;
this.eventRan = false;
};
var instanceProto = pluginProto.Instance.prototype;
instanceProto.onCreate = function()
{
jQuery(document).keydown(
(function (self) {
return function(info) {
self.onKeyDown(info);
};
})(this)
);
jQuery(document).keyup(
(function (self) {
return function(info) {
self.onKeyUp(info);
};
})(this)
);
};
instanceProto.onKeyDown = function (info)
{
if (this.keyMap[info.which])
{
if (this.usedKeys[info.which])
info.preventDefault();
return;
}
this.keyMap[info.which] = true;
this.eventRan = this.runtime.trigger(cr.plugins_.Keyboard.prototype.cnds.OnAnyKey, this);
this.triggerKey = info.which;
this.runtime.trigger(cr.plugins_.Keyboard.prototype.cnds.OnKey, this);
if (this.eventRan)
{
this.usedKeys[info.which] = true;
info.preventDefault();
}
};
instanceProto.onKeyUp = function (info)
{
this.keyMap[info.which] = false;
this.triggerKey = info.which;
this.eventRan = false;
this.runtime.trigger(cr.plugins_.Keyboard.prototype.cnds.OnKeyReleased, this);
if (this.eventRan || this.usedKeys[info.which])
{
this.usedKeys[info.which] = true;
info.preventDefault();
}
};
pluginProto.cnds = {};
var cnds = pluginProto.cnds;
cnds.IsKeyDown = function(key)
{
return this.keyMap[key];
};
cnds.OnKey = function(key)
{
var ret = (key === this.triggerKey);
this.eventRan = this.eventRan || ret;
return ret;
};
cnds.OnAnyKey = function(key)
{
return true;
};
cnds.OnKeyReleased = function(key)
{
var ret = (key === this.triggerKey);
this.eventRan = this.eventRan || ret;
return ret;
};
}());
;
;
cr.plugins_.Sprite = function(runtime)
{
this.runtime = runtime;
};
(function ()
{
var pluginProto = cr.plugins_.Sprite.prototype;
pluginProto.Type = function(plugin)
{
this.plugin = plugin;
this.runtime = plugin.runtime;
};
var typeProto = pluginProto.Type.prototype;
typeProto.onCreate = function()
{
var i, leni, j, lenj;
var anim, frame;
for (i = 0, leni = this.animations.length; i < leni; i++)
{
anim = this.animations[i];
anim.name = anim[0];
anim.speed = anim[1];
anim.loop = anim[2];
anim.repeatcount = anim[3];
anim.repeatto = anim[4];
anim.pingpong = anim[5];
anim.frames = anim[6];
for (j = 0, lenj = anim.frames.length; j < lenj; j++)
{
frame = anim.frames[j];
frame.texture_file = frame[0];
frame.texture_filesize = frame[1];
frame.duration = frame[2];
frame.hotspotX = frame[3];
frame.hotspotY = frame[4];
frame.image_points = frame[5];
frame.poly_pts = frame[6];
frame.texture_img = new Image();
frame.texture_img.src = frame[0];
frame.texture_img.cr_filesize = frame[1];
frame.webGL_texture = null;
this.runtime.wait_for_textures.push(frame.texture_img);
cr.seal(frame);
}
cr.seal(anim);
}
};
pluginProto.Instance = function(type)
{
this.type = type;
this.runtime = type.runtime;
this.collision_poly = new cr.CollisionPoly(this.type.animations[0].frames[0].poly_pts);
};
var instanceProto = pluginProto.Instance.prototype;
var fxNames = [ "lighter",
"xor",
"copy",
"destination-over",
"source-in",
"destination-in",
"source-out",
"destination-out",
"source-atop",
"destination-atop"];
instanceProto.effectToCompositeOp = function(effect)
{
if (effect <= 0 || effect >= 11)
return "source-over";
return fxNames[effect - 1];	// not including "none" so offset by 1
};
instanceProto.updateBlend = function(effect)
{
var gl = this.runtime.gl;
if (!gl)
return;
this.srcBlend = gl.ONE;
this.destBlend = gl.ONE_MINUS_SRC_ALPHA;
switch (effect) {
case 1:		// lighter (additive)
this.srcBlend = gl.ONE;
this.destBlend = gl.ONE;
break;
case 2:		// xor
break;	// todo
case 3:		// copy
this.srcBlend = gl.ONE;
this.destBlend = gl.ZERO;
break;
case 4:		// destination-over
this.srcBlend = gl.ONE_MINUS_DST_ALPHA;
this.destBlend = gl.ONE;
break;
case 5:		// source-in
this.srcBlend = gl.DST_ALPHA;
this.destBlend = gl.ZERO;
break;
case 6:		// destination-in
this.srcBlend = gl.ZERO;
this.destBlend = gl.SRC_ALPHA;
break;
case 7:		// source-out
this.srcBlend = gl.ONE_MINUS_DST_ALPHA;
this.destBlend = gl.ZERO;
break;
case 8:		// destination-out
this.srcBlend = gl.ZERO;
this.destBlend = gl.ONE_MINUS_SRC_ALPHA;
break;
case 9:		// source-atop
this.srcBlend = gl.DST_ALPHA;
this.destBlend = gl.ONE_MINUS_SRC_ALPHA;
break;
case 10:	// destination-atop
this.srcBlend = gl.ONE_MINUS_DST_ALPHA;
this.destBlend = gl.SRC_ALPHA;
break;
}	
};
instanceProto.onCreate = function()
{
this.visible = (this.properties[0] === 0);	// 0=visible, 1=invisible
this.compositeOp = this.effectToCompositeOp(this.properties[2]);
this.updateBlend(this.properties[2]);
this.isTicking = false;
this.inAnimTrigger = false;
if (!(this.type.animations.length === 1 && this.type.animations[0].frames.length === 1) && this.type.animations[0].speed !== 0)
{
this.runtime.tickMe(this);
this.isTicking = true;
}
this.cur_animation = this.type.animations[0];
this.cur_frame = this.properties[1];
if (this.cur_frame !== 0)
this.collision_poly.set_pts(this.cur_animation.frames[this.cur_frame].poly_pts);
if (this.cur_frame < 0)
this.cur_frame = 0;
if (this.cur_frame >= this.cur_animation.frames.length)
this.cur_frame = this.cur_animation.frames.length - 1;
this.cur_anim_speed = this.type.animations[0].speed;
this.frameStart = this.runtime.kahanTime.sum;
this.animPlaying = true;
this.animRepeats = 0;
this.animForwards = true;
this.animTriggerName = "";
this.changeAnimName = "";
this.changeAnimFrom = 0;
this.changeAnimFrame = -1;
var i, leni, j, lenj;
var anim, frame;
for (i = 0, leni = this.type.animations.length; i < leni; i++)
{
anim = this.type.animations[i];
for (j = 0, lenj = anim.frames.length; j < lenj; j++)
{
frame = anim.frames[j];
if (this.runtime.gl && !frame.webGL_texture)
frame.webGL_texture = this.runtime.glwrap.loadTexture(frame.texture_img, false, this.runtime.linearSampling);
}
}
this.curWebGLTexture = this.cur_animation.frames[this.cur_frame].webGL_texture;
};
instanceProto.tick = function()
{
if (this.changeAnimName.length)
this.doChangeAnim();
if (this.changeAnimFrame >= 0)
this.doChangeAnimFrame();
var now = this.runtime.kahanTime.sum;
var cur_animation = this.cur_animation;
var prev_frame = cur_animation.frames[this.cur_frame];
var next_frame;
var cur_frame_time = prev_frame.duration / this.cur_anim_speed;
if (this.animPlaying && now >= this.frameStart + cur_frame_time)
{			
if (this.animForwards)
{
this.cur_frame++;
}
else
{
this.cur_frame--;
}
this.frameStart += cur_frame_time;
if (this.cur_frame >= cur_animation.frames.length)
{
if (cur_animation.loop)
{
if (cur_animation.pingpong)
{
this.animForwards = false;
this.cur_frame = cur_animation.frames.length - 2;
}
else
{
this.cur_frame = cur_animation.repeatto;
}
}
else
{
this.animRepeats++;
if (this.animRepeats >= cur_animation.repeatcount)
{
this.cur_frame = cur_animation.frames.length - 1;
this.animTriggerName = cur_animation.name;
this.inAnimTrigger = true;
this.runtime.trigger(cr.plugins_.Sprite.prototype.cnds.OnAnyAnimFinished, this);
this.runtime.trigger(cr.plugins_.Sprite.prototype.cnds.OnAnimFinished, this);
this.inAnimTrigger = false;
if (!this.changeAnimName.length && this.changeAnimFrame === -1)
this.animPlaying = false;
}
else if (cur_animation.pingpong)
{
this.animForwards = false;
this.cur_frame = cur_animation.frames.length - 2;
}
else
{
this.cur_frame = cur_animation.repeatto;
}
}
}
if (this.cur_frame < 0)
{
if (cur_animation.pingpong)
{
this.cur_frame = 1;
this.animForwards = true;
}
else
{
if (cur_animation.loop)
{
this.cur_frame = cur_animation.repeatto;
}
else
{
this.animRepeats++;
if (this.animRepeats >= cur_animation.repeatcount)
{
this.cur_frame = 0;
this.animTriggerName = cur_animation.name;
this.inAnimTrigger = true;
this.runtime.trigger(cr.plugins_.Sprite.prototype.cnds.OnAnyAnimFinished, this);
this.runtime.trigger(cr.plugins_.Sprite.prototype.cnds.OnAnimFinished, this);
this.inAnimTrigger = false;
if (!this.changeAnimName.length && this.changeAnimFrame === -1)
this.animPlaying = false;
}
else
{
this.cur_frame = cur_animation.repeatto;
}
}
}
}
if (this.cur_frame < 0)
this.cur_frame = 0;
else if (this.cur_frame >= cur_animation.frames.length)
this.cur_frame = cur_animation.frames.length - 1;
if (now > this.frameStart + (cur_animation.frames[this.cur_frame].duration / this.cur_anim_speed))
{
this.frameStart = this.runtime.kahanTime.sum;
}
next_frame = cur_animation.frames[this.cur_frame];
this.OnFrameChanged(prev_frame, next_frame);
this.runtime.redraw = true;
}
};
instanceProto.doChangeAnim = function ()
{
var prev_frame = this.cur_animation.frames[this.cur_frame];
var i, len, a, anim = null;
for (i = 0, len = this.type.animations.length; i < len; i++)
{
a = this.type.animations[i];
if (a.name.toLowerCase() === this.changeAnimName.toLowerCase())
{
anim = a;
break;
}
}
this.changeAnimName = "";
if (!anim)
return;
if (anim.name.toLowerCase() === this.cur_animation.name.toLowerCase())
return;
this.cur_animation = anim;
this.cur_anim_speed = anim.speed;
if (this.cur_frame < 0)
this.cur_frame = 0;
if (this.cur_frame >= this.cur_animation.frames.length)
this.cur_frame = this.cur_animation.frames.length - 1;
if (this.changeAnimFrom === 1)
this.cur_frame = 0;
this.animPlaying = true;
this.frameStart = this.runtime.kahanTime.sum;
this.animForwards = true;
this.OnFrameChanged(prev_frame, this.cur_animation.frames[this.cur_frame]);
this.runtime.redraw = true;
};
instanceProto.doChangeAnimFrame = function ()
{
var prev_frame = this.cur_animation.frames[this.cur_frame];
var prev_frame_number = this.cur_frame;
this.cur_frame = Math.floor(this.changeAnimFrame);
if (this.cur_frame < 0)
this.cur_frame = 0;
if (this.cur_frame >= this.cur_animation.frames.length)
this.cur_frame = this.cur_animation.frames.length - 1;
if (prev_frame_number !== this.cur_frame)
{
this.OnFrameChanged(prev_frame, this.cur_animation.frames[this.cur_frame]);
this.frameStart = this.runtime.kahanTime.sum;
this.runtime.redraw = true;
}
this.changeAnimFrame = -1;
};
instanceProto.OnFrameChanged = function (prev_frame, next_frame)
{
var oldw = prev_frame.texture_img.width;
var oldh = prev_frame.texture_img.height;
var neww = next_frame.texture_img.width;
var newh = next_frame.texture_img.height;
if (oldw != neww)
this.width *= (neww / oldw);
if (oldh != newh)
this.height *= (newh / oldh);
this.hotspotX = next_frame.hotspotX;
this.hotspotY = next_frame.hotspotY;
this.collision_poly.set_pts(next_frame.poly_pts);
this.set_bbox_changed();
this.curWebGLTexture = next_frame.webGL_texture;
this.runtime.trigger(cr.plugins_.Sprite.prototype.cnds.OnFrameChanged, this);
};
instanceProto.draw = function(ctx)
{
if (this.opacity !== 1.0)
ctx.globalAlpha = this.opacity;
if (this.compositeOp !== "source-over")
ctx.globalCompositeOperation = this.compositeOp;
var cur_frame = this.cur_animation.frames[this.cur_frame];
var cur_image = cur_frame.texture_img;
var myx = this.x;
var myy = this.y;
if (this.runtime.pixel_rounding)
{
myx = Math.round(myx);
myy = Math.round(myy);
}
if (this.angle === 0 && this.width >= 0 && this.height >= 0)
{
ctx.drawImage(cur_image,
myx - (this.hotspotX * this.width),
myy - (this.hotspotY * this.height),
this.width,
this.height);
}
else
{
ctx.save();
var widthfactor = this.width > 0 ? 1 : -1;
var heightfactor = this.height > 0 ? 1 : -1;
ctx.translate(myx, myy);
ctx.scale(widthfactor, heightfactor);
ctx.rotate(this.angle * widthfactor * heightfactor);
ctx.drawImage(cur_image,
0 - (this.hotspotX * Math.abs(this.width)),
0 - (this.hotspotY * Math.abs(this.height)),
Math.abs(this.width),
Math.abs(this.height));
ctx.restore();
}
if (this.compositeOp !== "source-over")
ctx.globalCompositeOperation = "source-over";
if (this.opacity !== 1.0)
ctx.globalAlpha = 1.0;
/*
ctx.strokeStyle = "#f00";
ctx.lineWidth = 3;
ctx.beginPath();
this.collision_poly.cache_poly(this.width, this.height, this.angle);
var i, len, ax, ay, bx, by;
for (i = 0, len = this.collision_poly.pts_count; i < len; i++)
{
ax = this.collision_poly.pts_cache[i*2] + this.x;
ay = this.collision_poly.pts_cache[i*2+1] + this.y;
bx = this.collision_poly.pts_cache[((i+1)%len)*2] + this.x;
by = this.collision_poly.pts_cache[((i+1)%len)*2+1] + this.y;
ctx.moveTo(ax, ay);
ctx.lineTo(bx, by);
}
ctx.stroke();
ctx.closePath();
*/
/*
if (this.behavior_insts.length >= 1 && this.behavior_insts[0].draw)
{
this.behavior_insts[0].draw(ctx);
}
*/
};
instanceProto.drawGL = function(glw)
{
glw.setBlend(this.srcBlend, this.destBlend);
glw.setTexture(this.curWebGLTexture);
glw.setOpacity(this.opacity);
var q = this.bquad;
if (this.runtime.pixel_rounding)
{
var ox = Math.round(this.x) - this.x;
var oy = Math.round(this.y) - this.y;
glw.quad(q.tlx + ox, q.tly + oy, q.trx + ox, q.try_ + oy, q.brx + ox, q.bry + oy, q.blx + ox, q.bly + oy);
}
else
glw.quad(q.tlx, q.tly, q.trx, q.try_, q.brx, q.bry, q.blx, q.bly);
};
instanceProto.getImagePointIndexByName = function(name_)
{
var cur_frame = this.cur_animation.frames[this.cur_frame];
var i, len;
for (i = 0, len = cur_frame.image_points.length; i < len; i++)
{
if (name_.toLowerCase() === cur_frame.image_points[i][0].toLowerCase())
return i;
}
return -1;
};
instanceProto.getImagePoint = function(imgpt, getX)
{
var cur_frame = this.cur_animation.frames[this.cur_frame];
var image_points = cur_frame.image_points;
var index;
if (cr.is_string(imgpt))
index = this.getImagePointIndexByName(imgpt);
else
index = imgpt - 1;	// 0 is origin
index = Math.floor(index);
if (index < 0 || index >= image_points.length)
return getX ? this.x : this.y;	// return origin
var x = (image_points[index][1] - cur_frame.hotspotX) * this.width;
var y = image_points[index][2];
y = (y - cur_frame.hotspotY) * this.height;
var cosa = Math.cos(this.angle);
var sina = Math.sin(this.angle);
var x_temp = (x * cosa) - (y * sina);
y = (y * cosa) + (x * sina);
x = x_temp;
x += this.x;
y += this.y;
return getX ? x : y;
};
pluginProto.cnds = {};
var cnds = pluginProto.cnds;
function collmemory_add(collmemory, a, b)
{
collmemory.push([a, b]);
};
function collmemory_remove(collmemory, a, b)
{
var i, j = 0, len, entry;
for (i = 0, len = collmemory.length; i < len; i++)
{
entry = collmemory[i];
if (!((entry[0] === a && entry[1] === b) || (entry[0] === b && entry[1] === a)))
{
collmemory[j] = collmemory[i];
j++;
}
}
collmemory.length = j;
};
function collmemory_removeInstance(collmemory, inst)
{
var i, j = 0, len, entry;
for (i = 0, len = collmemory.length; i < len; i++)
{
entry = collmemory[i];
if (entry[0] !== inst && entry[1] !== inst)
{
collmemory[j] = collmemory[i];
j++;
}
}
collmemory.length = j;
};
function collmemory_has(collmemory, a, b)
{
var i, len, entry;
for (i = 0, len = collmemory.length; i < len; i++)
{
entry = collmemory[i];
if ((entry[0] === a && entry[1] === b) || (entry[0] === b && entry[1] === a))
return true;
}
return false;
};
cnds.OnCollision = function (rtype)
{	
if (!rtype)
return false;
var runtime = this.runtime;
var cnd = runtime.getCurrentCondition();
var ltype = cnd.type;
if (!cnd.extra.collmemory)
{
cnd.extra.collmemory = [];
runtime.addDestroyCallback((function (collmemory) {
return function(inst) {
collmemory_removeInstance(collmemory, inst);
};
})(cnd.extra.collmemory));
}
var lsol = ltype.getCurrentSol();
var rsol = rtype.getCurrentSol();
var linstances = lsol.getObjects();
var rinstances = rsol.getObjects();
var l, lenl, linst, r, lenr, rinst;
var curlsol, currsol;
var current_event = runtime.getCurrentEventStack().current_event;
for (l = 0, lenl = linstances.length; l < lenl; l++)
{
linst = linstances[l];
for (r = 0, lenr = rinstances.length; r < lenr; r++)
{
rinst = rinstances[r];
if (runtime.testOverlap(linst, rinst) || runtime.checkRegisteredCollision(linst, rinst))
{
if (!collmemory_has(cnd.extra.collmemory, linst, rinst))
{
collmemory_add(cnd.extra.collmemory, linst, rinst);
runtime.pushCopySol(current_event.solModifiers);
curlsol = ltype.getCurrentSol();
currsol = rtype.getCurrentSol();
curlsol.select_all = false;
currsol.select_all = false;
if (ltype === rtype)
{
curlsol.instances.length = 2;	// just use lsol, is same reference as rsol
curlsol.instances[0] = linst;
curlsol.instances[1] = rinst;
}
else
{
curlsol.instances.length = 1;
currsol.instances.length = 1;
curlsol.instances[0] = linst;
currsol.instances[0] = rinst;
}
current_event.retrigger();
runtime.popSol(current_event.solModifiers);
}
}
else
{
collmemory_remove(cnd.extra.collmemory, linst, rinst);
}
}
}
return false;
};
cnds.IsOverlapping = function (rtype)
{
if (!rtype)
return false;
var runtime = this.runtime;
var cnd = runtime.getCurrentCondition();
var ltype = cnd.type;
var lsol = ltype.getCurrentSol();
var rsol = rtype.getCurrentSol();
var linstances = lsol.getObjects();
var rinstances = rsol.getObjects();
var curlsol, currsol;
var l, lenl, linst, r, lenr, rinst;
var overlapped;
if (cnd.inverted)
{
var ldest = [];
for (l = 0, lenl = linstances.length; l < lenl; l++)
{
linst = linstances[l];
overlapped = false;
for (r = 0, lenr = rinstances.length; r < lenr; r++)
{
rinst = rinstances[r];
if (runtime.testOverlap(linst, rinst))
{
overlapped = true;
break;
}
}
if (!overlapped)
ldest.push(linst);
}
lsol.select_all = false;
lsol.instances = ldest;
return lsol.instances.length;
}
else
{
var current_event = runtime.getCurrentEventStack().current_event;
var temp_arr = [];
for (l = 0, lenl = linstances.length; l < lenl; l++)
{
linst = linstances[l];
for (r = 0, lenr = rinstances.length; r < lenr; r++)
{
rinst = rinstances[r];
if (runtime.testOverlap(linst, rinst))
{
runtime.pushCopySol(current_event.solModifiers);
curlsol = ltype.getCurrentSol();
currsol = rtype.getCurrentSol();
curlsol.select_all = false;
currsol.select_all = false;
if (ltype === rtype)
{
if (collmemory_has(temp_arr, linst, rinst))
{
runtime.popSol(current_event.solModifiers);
continue;
}
else
{
collmemory_add(temp_arr, linst, rinst);	// prevent running for second instance
curlsol.instances.length = 2;
curlsol.instances[0] = linst;
curlsol.instances[1] = rinst;
}
}
else
{
curlsol.instances.length = 1;
currsol.instances.length = 1;
curlsol.instances[0] = linst;
currsol.instances[0] = rinst;
}
current_event.retrigger();
runtime.popSol(current_event.solModifiers);
}
}
}
return false;
}
};
cnds.IsAnimPlaying = function (animname)
{
return this.cur_animation.name.toLowerCase() === animname.toLowerCase();
};
cnds.CompareFrame = function (cmp, framenum)
{
return cr.do_cmp(this.cur_frame, cmp, framenum);
};
cnds.OnAnimFinished = function (animname)
{
return this.animTriggerName.toLowerCase() === animname.toLowerCase();
};
cnds.OnAnyAnimFinished = function ()
{
return true;
};
cnds.OnFrameChanged = function ()
{
return true;
};
cnds.IsMirrored = function ()
{
return this.width < 0;
};
cnds.IsFlipped = function ()
{
return this.height < 0;
};
pluginProto.acts = {};
var acts = pluginProto.acts;
acts.Spawn = function (obj, layer, imgpt)
{
if (!obj || !layer)
return;
var inst = this.runtime.createInstance(obj, layer, this.getImagePoint(imgpt, true), this.getImagePoint(imgpt, false));
inst.angle = this.angle;
inst.set_bbox_changed();
var cur_act = this.runtime.getCurrentAction();
var reset_sol = false;
if (cr.is_undefined(cur_act.extra.Spawn_LastExec) || cur_act.extra.Spawn_LastExec < this.runtime.execcount)
{
reset_sol = true;
cur_act.extra.Spawn_LastExec = this.runtime.execcount;
}
var sol = obj.getCurrentSol();
sol.select_all = false;
if (reset_sol)
{
sol.instances.length = 1;
sol.instances[0] = inst;
}
else
sol.instances.push(inst);
};
acts.SetEffect = function (effect)
{
this.compositeOp = this.effectToCompositeOp(effect);
this.updateBlend(effect);
this.runtime.redraw = true;
};
acts.StopAnim = function ()
{
this.animPlaying = false;
};
acts.StartAnim = function (from)
{
this.animPlaying = true;
this.frameStart = this.runtime.kahanTime.sum;
if (from === 1 && this.cur_frame !== 0)
{
var prev_frame = this.cur_animation.frames[this.cur_frame];
this.cur_frame = 0;
this.OnFrameChanged(prev_frame, this.cur_animation.frames[0]);
this.runtime.redraw = true;
}
if (!this.isTicking)
{
this.runtime.tickMe(this);
this.isTicking = true;
}
};
acts.SetAnim = function (animname, from)
{
this.changeAnimName = animname;
this.changeAnimFrom = from;
if (!this.isTicking)
{
this.runtime.tickMe(this);
this.isTicking = true;
}
if (!this.inAnimTrigger)
this.doChangeAnim();
};
acts.SetAnimFrame = function (framenumber)
{
this.changeAnimFrame = framenumber;
if (!this.isTicking)
{
this.runtime.tickMe(this);
this.isTicking = true;
}
if (!this.inAnimTrigger)
this.doChangeAnimFrame();
};
acts.SetAnimSpeed = function (s)
{
this.cur_anim_speed = Math.abs(s);
this.animForwards = (s >= 0);
if (!this.isTicking)
{
this.runtime.tickMe(this);
this.isTicking = true;
}
};
acts.SetMirrored = function (m)
{
var neww = Math.abs(this.width) * (m === 0 ? -1 : 1);
if (this.width === neww)
return;
this.width = neww;
this.set_bbox_changed();
};
acts.SetFlipped = function (f)
{
var newh = Math.abs(this.height) * (f === 0 ? -1 : 1);
if (this.height === newh)
return;
this.height = newh;
this.set_bbox_changed();
};
pluginProto.exps = {};
var exps = pluginProto.exps;
exps.AnimationFrame = function (ret)
{
ret.set_int(this.cur_frame);
};
exps.AnimationFrameCount = function (ret)
{
ret.set_int(this.cur_animation.frames.length);
};
exps.AnimationName = function (ret)
{
ret.set_string(this.cur_animation.name);
};
exps.AnimationSpeed = function (ret)
{
ret.set_float(this.cur_anim_speed);
};
exps.ImagePointX = function (ret, imgpt)
{
ret.set_float(this.getImagePoint(imgpt, true));
};
exps.ImagePointY = function (ret, imgpt)
{
ret.set_float(this.getImagePoint(imgpt, false));
};
exps.ImageWidth = function (ret)
{
ret.set_float(this.cur_animation.frames[this.cur_frame].texture_img.width);
};
exps.ImageHeight = function (ret)
{
ret.set_float(this.cur_animation.frames[this.cur_frame].texture_img.height);
};
}());
;
;
cr.plugins_.Text = function(runtime)
{
this.runtime = runtime;
};
(function ()
{
var pluginProto = cr.plugins_.Text.prototype;
pluginProto.onCreate = function ()
{
pluginProto.acts.SetWidth = function (w)
{
if (this.width !== w)
{
this.width = w;
this.text_changed = true;	// also recalculate text wrapping
this.set_bbox_changed();
}
};
};
pluginProto.Type = function(plugin)
{
this.plugin = plugin;
this.runtime = plugin.runtime;
};
var typeProto = pluginProto.Type.prototype;
typeProto.onCreate = function()
{
};
pluginProto.Instance = function(type)
{
this.type = type;
this.runtime = type.runtime;
this.lines = [];		// for word wrapping
this.text_changed = true;
};
var instanceProto = pluginProto.Instance.prototype;
instanceProto.onCreate = function()
{
this.text = this.properties[0];
this.visible = (this.properties[1] === 0);	// 0=visible, 1=invisible
this.font = this.properties[2];
this.color = this.properties[3];
this.halign = this.properties[4];			// 0=left, 1=center, 2=right
var arr = this.font.split(" ");
var ptSize = 0;
var i;
for (i = 0; i < arr.length; i++)
{
if (arr[i].substr(arr[i].length - 2, 2) === "pt")
{
ptSize = parseInt(arr[i].substr(0, arr[i].length - 2));
this.pxHeight = Math.ceil((ptSize / 72.0) * 96.0) + 4;	// assume 96dpi...
break;
}
}
;
};
instanceProto.draw = function(ctx)
{
ctx.font = this.font;
ctx.textBaseline = "top";
ctx.fillStyle = this.color;
if (this.opacity !== 1.0)
ctx.globalAlpha = this.opacity;
if (this.text_changed)
{
this.type.plugin.WordWrap(this.text, this.lines, ctx, this.width);
this.text_changed = false;
}
var penX = this.x - (this.hotspotX * this.width);
var penY = this.y - (this.hotspotY * this.height);
if (this.runtime.pixel_rounding)
{
penX = Math.round(penX);
penY = Math.round(penY);
}
var endY = penY + this.height;
var line_height = this.pxHeight;
var drawX;
var i;
for (i = 0; i < this.lines.length; i++)
{
drawX = penX;
if (this.halign === 1)		// center
drawX = penX + (this.width - this.lines[i].width) / 2;
else if (this.halign === 2)	// right
drawX = penX + (this.width - this.lines[i].width);
ctx.fillText(this.lines[i].text, drawX, penY);
penY += line_height;
if (penY >= endY - line_height)
break;
}
if (this.opacity !== 1.0)
ctx.globalAlpha = 1.0;
};
instanceProto.drawGL = function(glw)
{
if (this.runtime.overlay_ctx)
this.draw(this.runtime.overlay_ctx);
};
var wordsCache = [];
pluginProto.TokeniseWords = function (text)
{
wordsCache.length = 0;
var cur_word = "";
var ch;
var i = 0;
while (i < text.length)
{
ch = text.charAt(i);
if (ch === "\n")
{
if (cur_word.length)
{
wordsCache.push(cur_word);
cur_word = "";
}
wordsCache.push("\n");
++i;
}
else if (ch === " " || ch === "\t" || ch === "-")
{
do {
cur_word += text.charAt(i);
i++;
}
while (i < text.length && (text.charAt(i) === " " || text.charAt(i) === "\t"));
wordsCache.push(cur_word);
cur_word = "";
}
else if (i < text.length)
{
cur_word += ch;
i++;
}
}
if (cur_word.length)
wordsCache.push(cur_word);
};
pluginProto.WordWrap = function (text, lines, ctx, width)
{
if (!text || !text.length)
{
lines.length = 0;
return;
}
if (width <= 2.0)
{
lines.length = 0;
return;
}
if (text.length <= 100 && text.indexOf("\n") === -1)
{
var all_width = ctx.measureText(text).width;
if (all_width <= width)
{
if (lines.length)
lines.length = 1;
else
lines.push({});
lines[0].text = text;
lines[0].width = all_width;
return;
}
}
this.WordWrapByWord(text, lines, ctx, width);
};
pluginProto.WordWrapByWord = function (text, lines, ctx, width)
{
this.TokeniseWords(text);	// writes to wordsCache
var cur_line = "";
var prev_line;
var line_width;
var i;
var lineIndex = 0;
var line;
for (i = 0; i < wordsCache.length; i++)
{
if (wordsCache[i] === "\n")
{
if (lineIndex >= lines.length)
lines.push({});
line = lines[lineIndex];
line.text = cur_line;
line.width = ctx.measureText(cur_line).width;
lineIndex++;
cur_line = "";
continue;
}
prev_line = cur_line;
cur_line += wordsCache[i];
line_width = ctx.measureText(cur_line).width;
if (line_width >= width)
{
if (lineIndex >= lines.length)
lines.push({});
line = lines[lineIndex];
line.text = prev_line;
line.width = ctx.measureText(prev_line).width;
lineIndex++;
cur_line = wordsCache[i];
}
}
if (cur_line.length)
{
if (lineIndex >= lines.length)
lines.push({});
line = lines[lineIndex];
line.text = cur_line;
line.width = ctx.measureText(cur_line).width;
lineIndex++;
}
lines.length = lineIndex;
};
pluginProto.cnds = {};
var cnds = pluginProto.cnds;
cnds.CompareText = function(text_to_compare, case_sensitive)
{
if (case_sensitive)
return this.text == text_to_compare;
else
return this.text.toLowerCase() == text_to_compare.toLowerCase();
};
pluginProto.acts = {};
var acts = pluginProto.acts;
acts.SetText = function(param)
{
if (cr.is_number(param))
param = Math.round(param * 1e10) / 1e10;	// round to nearest ten billionth - hides floating point errors
var text_to_set = param.toString();
if (this.text !== text_to_set)
{
this.text = text_to_set;
this.text_changed = true;
this.runtime.redraw = true;
}
};
acts.AppendText = function(param)
{
if (cr.is_number(param))
param = Math.round(param * 1e10) / 1e10;	// round to nearest ten billionth - hides floating point errors
var text_to_append = param.toString();
if (text_to_append)	// not empty
{
this.text += text_to_append;
this.text_changed = true;
this.runtime.redraw = true;
}
};
pluginProto.exps = {};
var exps = pluginProto.exps;
exps.Text = function(ret)
{
ret.set_string(this.text);
};
}());
;
;
cr.behaviors.Bullet = function(runtime)
{
this.runtime = runtime;
};
(function ()
{
var behaviorProto = cr.behaviors.Bullet.prototype;
behaviorProto.Type = function(behavior, objtype)
{
this.behavior = behavior;
this.objtype = objtype;
this.runtime = behavior.runtime;
};
var behtypeProto = behaviorProto.Type.prototype;
behtypeProto.onCreate = function()
{
};
behaviorProto.Instance = function(type, inst)
{
this.type = type;
this.behavior = type.behavior;
this.inst = inst;				// associated object instance to modify
this.runtime = type.runtime;
};
var behinstProto = behaviorProto.Instance.prototype;
behinstProto.onCreate = function()
{
var speed = this.properties[0];
this.acc = this.properties[1];
this.g = this.properties[2];
this.bounceOffSolid = (this.properties[3] !== 0);
this.setAngle = (this.properties[4] !== 0);
this.dx = Math.cos(this.inst.angle) * speed;
this.dy = Math.sin(this.inst.angle) * speed;
this.lastx = this.inst.x;
this.lasty = this.inst.y;		
this.lastKnownAngle = this.inst.angle;
this.enabled = true;
};
behinstProto.tick = function ()
{
if (!this.enabled)
return;
var dt = this.runtime.getDt(this.inst);
var s, a;
var bounceSolid, bounceAngle;
if (this.inst.angle !== this.lastKnownAngle)
{
s = cr.distanceTo(0, 0, this.dx, this.dy);
this.dx = Math.cos(this.inst.angle) * s;
this.dy = Math.sin(this.inst.angle) * s;
this.lastKnownAngle = this.inst.angle;
}
if (this.acc !== 0)
{
s = cr.distanceTo(0, 0, this.dx, this.dy);
if (this.dx === 0 && this.dy === 0)
a = this.inst.angle;
else
a = cr.angleTo(0, 0, this.dx, this.dy);
s += this.acc * dt;
if (s < 0)
s = 0;
this.dx = Math.cos(a) * s;
this.dy = Math.sin(a) * s;
}
if (this.g !== 0)
this.dy += this.g * dt;
this.lastx = this.inst.x;
this.lasty = this.inst.y;
if (this.dx !== 0 || this.dy !== 0)
{
this.inst.x += this.dx * dt;
this.inst.y += this.dy * dt;
if (this.setAngle)
{
this.inst.angle = cr.angleTo(0, 0, this.dx, this.dy);
this.inst.set_bbox_changed();
this.lastKnownAngle = this.inst.angle;
}
this.inst.set_bbox_changed();
if (this.bounceOffSolid)
{
bounceSolid = this.runtime.testOverlapSolid(this.inst);
if (bounceSolid)
{
this.runtime.registerCollision(this.inst, bounceSolid);
s = cr.distanceTo(0, 0, this.dx, this.dy);
bounceAngle = this.runtime.calculateSolidBounceAngle(this.inst, this.lastx, this.lasty);
this.dx = Math.cos(bounceAngle) * s;
this.dy = Math.sin(bounceAngle) * s;
this.inst.x += this.dx * dt;			// move out for one tick since the object can't have spent a tick in the solid
this.inst.y += this.dy * dt;
this.inst.set_bbox_changed();
if (this.setAngle)
{
this.inst.angle = bounceAngle;
this.lastKnownAngle = bounceAngle;
this.inst.set_bbox_changed();
}
if (!this.runtime.pushOutSolid(this.inst, this.dx / s, this.dy / s, Math.max(s * 2.5 * dt, 30)))
this.runtime.pushOutSolidNearest(this.inst, 100);
}
}
}
};
behaviorProto.cnds = {};
var cnds = behaviorProto.cnds;
cnds.CompareSpeed = function (cmp, s)
{
return cr.do_cmp(cr.distanceTo(0, 0, this.dx, this.dy), cmp, s);
};
behaviorProto.acts = {};
var acts = behaviorProto.acts;
acts.SetSpeed = function (s)
{
if (s < 0)
s = 0;
var a = cr.angleTo(0, 0, this.dx, this.dy);
this.dx = Math.cos(a) * s;
this.dy = Math.sin(a) * s;
};
acts.SetAcceleration = function (a)
{
this.acc = a;
};
acts.SetGravity = function (g)
{
this.g = g;
};
acts.SetAngleOfMotion = function (a)
{
a = cr.to_radians(a);
var s = cr.distanceTo(0, 0, this.dx, this.dy)
this.dx = Math.cos(a) * s;
this.dy = Math.sin(a) * s;
};
acts.Bounce = function (objtype)
{
if (!objtype)
return;
var otherinst = objtype.getFirstPicked();
if (!otherinst)
return;
var dt = this.runtime.getDt(this.inst);
var s = cr.distanceTo(0, 0, this.dx, this.dy);
var bounceAngle = this.runtime.calculateSolidBounceAngle(this.inst, this.lastx, this.lasty, otherinst);
this.dx = Math.cos(bounceAngle) * s;
this.dy = Math.sin(bounceAngle) * s;
this.inst.x += this.dx * dt;			// move out for one tick since the object can't have spent a tick in the solid
this.inst.y += this.dy * dt;
this.inst.set_bbox_changed();
if (this.setAngle)
{
this.inst.angle = bounceAngle;
this.lastKnownAngle = bounceAngle;
this.inst.set_bbox_changed();
}
if (!this.runtime.pushOutSolid(this.inst, this.dx / s, this.dy / s, Math.max(s * 2.5 * dt, 30)))
this.runtime.pushOutSolidNearest(this.inst, 100);
};
acts.SetEnabled = function (en)
{
this.enabled = (en === 1);
};
behaviorProto.exps = {};
var exps = behaviorProto.exps;
exps.Speed = function (ret)
{
var s = cr.distanceTo(0, 0, this.dx, this.dy);
s = Math.round(s * 1000000) / 1000000;
ret.set_float(s);
};
exps.Acceleration = function (ret)
{
ret.set_float(this.acc);
};
exps.AngleOfMotion = function (ret)
{
ret.set_float(cr.angleTo(0, 0, this.dx, this.dy));
};
}());
;
;
cr.behaviors.Fade = function(runtime)
{
this.runtime = runtime;
};
(function ()
{
var behaviorProto = cr.behaviors.Fade.prototype;
behaviorProto.Type = function(behavior, objtype)
{
this.behavior = behavior;
this.objtype = objtype;
this.runtime = behavior.runtime;
};
var behtypeProto = behaviorProto.Type.prototype;
behtypeProto.onCreate = function()
{
};
behaviorProto.Instance = function(type, inst)
{
this.type = type;
this.behavior = type.behavior;
this.inst = inst;				// associated object instance to modify
this.runtime = type.runtime;
};
var behinstProto = behaviorProto.Instance.prototype;
behinstProto.onCreate = function()
{
this.fadeInTime = this.properties[0];
this.waitTime = this.properties[1];
this.fadeOutTime = this.properties[2];
this.destroy = this.properties[3];	// 0 = no, 1 = after fade out
this.stage = 0;						// 0 = fade in, 1 = wait, 2 = fade out, 3 = done
this.stageTime = new cr.KahanAdder();
this.maxOpacity = (this.inst.opacity ? this.inst.opacity : 1.0);
if (this.fadeInTime === 0)
{
this.stage = 1;
if (this.waitTime === 0)
this.stage = 2;
}
else
{
this.inst.opacity = 0;
this.runtime.redraw = true;
}
};
behinstProto.tick = function ()
{
this.stageTime.add(this.runtime.getDt(this.inst));
if (this.stage === 0)
{
this.inst.opacity = (this.stageTime.sum / this.fadeInTime) * this.maxOpacity;
this.runtime.redraw = true;
if (this.inst.opacity >= this.maxOpacity)
{
this.inst.opacity = this.maxOpacity;
this.stage = 1;	// wait stage
this.stageTime.reset();
}
}
if (this.stage === 1)
{
if (this.stageTime.sum >= this.waitTime)
{
this.stage = 2;	// fade out stage
this.stageTime.reset();
}
}
if (this.stage === 2)
{
if (this.fadeOutTime !== 0)
{
this.inst.opacity = this.maxOpacity - ((this.stageTime.sum / this.fadeOutTime) * this.maxOpacity);
this.runtime.redraw = true;
if (this.inst.opacity < 0)
{
this.inst.opacity = 0;
this.stage = 3;	// done
this.stageTime.reset();
this.runtime.trigger(cr.behaviors.Fade.prototype.cnds.OnFadeOutEnd, this.inst);
if (this.destroy === 1)
this.runtime.DestroyInstance(this.inst);
}
}
}
};
behaviorProto.cnds = {};
var cnds = behaviorProto.cnds;
cnds.OnFadeOutEnd = function ()
{
return true;
};
behaviorProto.acts = {};
var acts = behaviorProto.acts;
acts.RestartFade = function ()
{
this.stage = 0;
this.stageTime.reset();
if (this.fadeInTime === 0)
{
this.stage = 1;
if (this.waitTime === 0)
this.stage = 2;
}
else
{
this.inst.opacity = 0;
this.runtime.redraw = true;
}
};
}());
;
;
cr.behaviors.Platform = function(runtime)
{
this.runtime = runtime;
};
(function ()
{
var behaviorProto = cr.behaviors.Platform.prototype;
behaviorProto.Type = function(behavior, objtype)
{
this.behavior = behavior;
this.objtype = objtype;
this.runtime = behavior.runtime;
};
var behtypeProto = behaviorProto.Type.prototype;
behtypeProto.onCreate = function()
{
};
var ANIMMODE_STOPPED = 0;
var ANIMMODE_MOVING = 1;
var ANIMMODE_JUMPING = 2;
var ANIMMODE_FALLING = 3;
behaviorProto.Instance = function(type, inst)
{
this.type = type;
this.behavior = type.behavior;
this.inst = inst;				// associated object instance to modify
this.runtime = type.runtime;
this.leftkey = false;
this.rightkey = false;
this.jumpkey = false;
this.jumped = false;		// prevent bunnyhopping
this.ignoreInput = false;
this.simleft = false;
this.simright = false;
this.simjump = false;
this.lastFloorObject = null;
this.lastFloorX = 0;
this.lastFloorY = 0;
this.animMode = ANIMMODE_STOPPED;
this.enabled = true;
this.dx = 0;
this.dy = 0;
};
var behinstProto = behaviorProto.Instance.prototype;
function roundTo6dp(x)
{
return Math.round(x * 1000000) / 1000000;
};
behinstProto.updateGravity = function()
{
this.downx = Math.cos(this.ga);
this.downy = Math.sin(this.ga);
this.rightx = Math.cos(this.ga - Math.PI / 2);
this.righty = Math.sin(this.ga - Math.PI / 2);
this.downx = roundTo6dp(this.downx);
this.downy = roundTo6dp(this.downy);
this.rightx = roundTo6dp(this.rightx);
this.righty = roundTo6dp(this.righty);
if (this.g < 0)
{
this.downx *= -1;
this.downy *= -1;
this.g = Math.abs(this.g);
}
};
behinstProto.onCreate = function()
{
this.maxspeed = this.properties[0];
this.acc = this.properties[1];
this.dec = this.properties[2];
this.jumpStrength = this.properties[3];
this.g = this.properties[4];
this.maxFall = this.properties[5];
this.defaultControls = (this.properties[6] === 1);	// 0=no, 1=yes
this.ga = cr.to_radians(90);
this.updateGravity();
if (this.defaultControls)
{
jQuery(document).keydown(
(function (self) {
return function(info) {
self.onKeyDown(info);
};
})(this)
);
jQuery(document).keyup(
(function (self) {
return function(info) {
self.onKeyUp(info);
};
})(this)
);
}
this.runtime.addDestroyCallback((function (self) {
return function(inst) {
self.onInstanceDestroyed(inst);
};
})(this)
);
};
behinstProto.onInstanceDestroyed = function (inst)
{
if (this.lastFloorObject == inst)
this.lastFloorObject = null;
};
behinstProto.onDestroy = function ()
{
this.lastFloorObject = null;
};
behinstProto.onKeyDown = function (info)
{	
switch (info.which) {
case 16:	// shift
info.preventDefault();
this.jumpkey = true;
break;
case 37:	// left
info.preventDefault();
this.leftkey = true;
break;
case 39:	// right
info.preventDefault();
this.rightkey = true;
break;
}
};
behinstProto.onKeyUp = function (info)
{
switch (info.which) {
case 16:	// shift
info.preventDefault();
this.jumpkey = false;
this.jumped = false;
break;
case 37:	// left
info.preventDefault();
this.leftkey = false;
break;
case 39:	// right
info.preventDefault();
this.rightkey = false;
break;
}
};
behinstProto.getGDir = function ()
{
if (this.g < 0)
return -1;
else
return 1;
};
behinstProto.isOnFloor = function ()
{
var ret;
var oldx = this.inst.x;
var oldy = this.inst.y;
this.inst.x += this.downx;
this.inst.y += this.downy;
this.inst.set_bbox_changed();
if (this.lastFloorObject && this.runtime.testOverlap(this.inst, this.lastFloorObject))
{
this.inst.x = oldx;
this.inst.y = oldy;
this.inst.set_bbox_changed();
return this.lastFloorObject;
}
else
{
ret = this.runtime.testOverlapSolid(this.inst) || this.runtime.testOverlapJumpThru(this.inst);
this.inst.x = oldx;
this.inst.y = oldy;
this.inst.set_bbox_changed();
if (ret && this.runtime.testOverlap(this.inst, ret))
return null;
return ret;
}
};
behinstProto.tick = function ()
{
var dt = this.runtime.getDt(this.inst);
var mx, my, obstacle, mag;
if (!this.defaultControls && !this.simjump)
this.jumped = false;
var left = this.leftkey || this.simleft;
var right = this.rightkey || this.simright;
var jump = (this.jumpkey || this.simjump) && !this.jumped;
this.simleft = false;
this.simright = false;
this.simjump = false;
if (!this.enabled)
return;
this.inst.x -= this.downx;
this.inst.y -= this.downy;
this.inst.set_bbox_changed();
if (this.ignoreInput)
{
left = false;
right = false;
jump = false;
}
var floor_ = this.isOnFloor();
var lastFloor = this.lastFloorObject;
var collobj = this.runtime.testOverlapSolid(this.inst);
if (collobj)
{
if (this.runtime.pushOutSolidNearest(this.inst, Math.max(this.inst.width, this.inst.height) / 2))
this.runtime.registerCollision(this.inst, collobj);
else
{
this.inst.x += this.downx;
this.inst.y += this.downy;
this.inst.set_bbox_changed();
return;
}
}
if (floor_)
{
if (this.dy > 0)
this.dy = 0;
if (lastFloor != floor_)
{
this.lastFloorObject = floor_;
this.lastFloorX = floor_.x;
this.lastFloorY = floor_.y;
this.runtime.registerCollision(this.inst, floor_);
}
else if (floor_.x !== this.lastFloorX || floor_.y !== this.lastFloorY)
{
mx = (floor_.x - this.lastFloorX);
my = (floor_.y - this.lastFloorY);
this.inst.x += mx;
this.inst.y += my;
this.inst.set_bbox_changed();
this.lastFloorX = floor_.x;
this.lastFloorY = floor_.y;
collobj = this.runtime.testOverlapSolid(this.inst);
if (collobj)
{
this.runtime.registerCollision(this.inst, collobj);
if (mx !== 0)
{
if (mx > 0)
this.runtime.pushOutSolid(this.inst, -this.rightx, -this.righty);
else
this.runtime.pushOutSolid(this.inst, this.rightx, this.righty);
}
this.runtime.pushOutSolid(this.inst, -this.downx, -this.downy);
}
}
if (jump)
{
this.runtime.trigger(cr.behaviors.Platform.prototype.cnds.OnJump, this.inst);
this.animMode = ANIMMODE_JUMPING;
this.dy = -this.jumpStrength;
this.jumped = true;
}
}
else
{
this.lastFloorObject = null;
this.dy += this.g * dt;
if (this.dy > this.maxFall)
this.dy = this.maxFall;
}
if (left == right)	// both up or both down
{
if (this.dx < 0)
{
this.dx += this.dec * dt;
if (this.dx > 0)
this.dx = 0;
}
else if (this.dx > 0)
{
this.dx -= this.dec * dt;
if (this.dx < 0)
this.dx = 0;
}
}
if (left && !right)
{
if (this.dx > 0)
this.dx -= (this.acc + this.dec) * dt;
else
this.dx -= this.acc * dt;
}
if (right && !left)
{
if (this.dx < 0)
this.dx += (this.acc + this.dec) * dt;
else
this.dx += this.acc * dt;
}
if (this.dx > this.maxspeed)
this.dx = this.maxspeed;
else if (this.dx < -this.maxspeed)
this.dx = -this.maxspeed;
if (this.dx !== 0)
{		
var oldx = this.inst.x;
var oldy = this.inst.y;
mx = this.dx * dt * this.rightx;
my = this.dx * dt * this.righty;
this.inst.x += this.rightx * (this.dx > 1 ? 1 : -1) - this.downx;
this.inst.y += this.righty * (this.dx > 1 ? 1 : -1) - this.downy;
this.inst.set_bbox_changed();
var slope_too_steep = this.runtime.testOverlapSolid(this.inst);
this.inst.x = oldx + mx;
this.inst.y = oldy + my;
this.inst.set_bbox_changed();
obstacle = this.runtime.testOverlapSolid(this.inst);
if (obstacle)
{
var push_dist = Math.abs(this.dx * dt) + 2;
if (slope_too_steep || !this.runtime.pushOutSolid(this.inst, -this.downx, -this.downy, push_dist))
{
this.runtime.registerCollision(this.inst, obstacle);
push_dist = Math.max(Math.abs(this.dx * dt * 2.5), 30);
if (!this.runtime.pushOutSolid(this.inst, this.rightx * (this.dx < 0 ? 1 : -1), this.righty * (this.dx < 0 ? 1 : -1), push_dist))
{
this.inst.x = oldx;
this.inst.y = oldy;
this.inst.set_bbox_changed();
}
else if (Math.abs(this.inst.x - oldx) < 1)
{
this.inst.x = oldx;
this.inst.y = oldy;
this.inst.set_bbox_changed();
}
this.dx = 0;	// stop
}
}
else if (floor_ && !this.isOnFloor())
{
mag = Math.ceil(this.dx * dt) + 1;
oldx = this.inst.x;
oldy = this.inst.y;
this.inst.x += this.downx * mag;
this.inst.y += this.downy * mag;
this.inst.set_bbox_changed();
if (this.runtime.testOverlapSolid(this.inst))
this.runtime.pushOutSolid(this.inst, -this.downx, -this.downy, mag + 2);
else
{
this.inst.x = oldx;
this.inst.y = oldy;
this.inst.set_bbox_changed();
}
}
}
if (this.dy !== 0)
{
var oldx = this.inst.x;
var oldy = this.inst.y;
this.inst.x += this.dy * dt * this.downx;
this.inst.y += this.dy * dt * this.downy;
var newx = this.inst.x;
var newy = this.inst.y;
this.inst.set_bbox_changed();
collobj = this.runtime.testOverlapSolid(this.inst);
var fell_on_jumpthru = false;
if (!collobj && (this.dy > 0) && !floor_)
{
collobj = this.runtime.testOverlapJumpThru(this.inst);
if (collobj)
{
this.inst.x = oldx;
this.inst.y = oldy;
this.inst.set_bbox_changed();
if (this.runtime.testOverlap(this.inst, collobj))
collobj = null;
this.inst.x = newx;
this.inst.y = newy;
this.inst.set_bbox_changed();
}
fell_on_jumpthru = !!collobj;
}
if (collobj)
{
this.runtime.registerCollision(this.inst, collobj);
var push_dist = fell_on_jumpthru ? (this.dy * dt + 1) : Math.max(Math.abs(this.dy * dt * 2.5), 30);
if (!this.runtime.pushOutSolid(this.inst, this.downx * (this.dy < 0 ? 1 : -1), this.downy * (this.dy < 0 ? 1 : -1), push_dist, fell_on_jumpthru))
{
this.inst.x = oldx;
this.inst.y = oldy;
this.inst.set_bbox_changed();
}
this.dy = 0;	// stop
}
}
this.inst.x += this.downx;
this.inst.y += this.downy;
this.inst.set_bbox_changed();
if (this.animMode !== ANIMMODE_FALLING && this.dy > 0 && !floor_)
{
this.runtime.trigger(cr.behaviors.Platform.prototype.cnds.OnFall, this.inst);
this.animMode = ANIMMODE_FALLING;
}
if (floor_)
{
if (this.animMode === ANIMMODE_FALLING)
{
this.runtime.trigger(cr.behaviors.Platform.prototype.cnds.OnLand, this.inst);
if (this.dx === 0 && this.dy === 0)
this.animMode = ANIMMODE_STOPPED;
else
this.animMode = ANIMMODE_MOVING;
}
else
{
if (this.animMode !== ANIMMODE_STOPPED && this.dx === 0 && this.dy === 0)
{
this.runtime.trigger(cr.behaviors.Platform.prototype.cnds.OnStop, this.inst);
this.animMode = ANIMMODE_STOPPED;
}
if (this.animMode !== ANIMMODE_MOVING && (this.dx !== 0 || this.dy !== 0) && !jump)
{
this.runtime.trigger(cr.behaviors.Platform.prototype.cnds.OnMove, this.inst);
this.animMode = ANIMMODE_MOVING;
}
}
}
};
behaviorProto.cnds = {};
var cnds = behaviorProto.cnds;
cnds.IsMoving = function ()
{
return this.dx !== 0 || this.dy !== 0;
};
cnds.CompareSpeed = function (cmp, s)
{
var speed = Math.sqrt(this.dx * this.dx + this.dy * this.dy);
return cr.do_cmp(speed, cmp, s);
};
cnds.IsOnFloor = function ()
{
if (!this.runtime.testOverlapSolid(this.inst))
return false;
var ret = false;
var oldx = this.inst.x;
var oldy = this.inst.y;
this.inst.x -= this.downx;
this.inst.y -= this.downy;
this.inst.set_bbox_changed();
ret = !this.runtime.testOverlapSolid(this.inst)
this.inst.x = oldx;
this.inst.y = oldy;
this.inst.set_bbox_changed();
return ret;
};
cnds.IsJumping = function ()
{
return this.dy < 0;
};
cnds.IsFalling = function ()
{
return this.dy > 0;
};
cnds.OnJump = function ()
{
return true;
};
cnds.OnFall = function ()
{
return true;
};
cnds.OnStop = function ()
{
return true;
};
cnds.OnMove = function ()
{
return true;
};
cnds.OnLand = function ()
{
return true;
};
behaviorProto.acts = {};
var acts = behaviorProto.acts;
acts.SetIgnoreInput = function (ignoring)
{
this.ignoreInput = ignoring;
};
acts.SetMaxSpeed = function (maxspeed)
{
this.maxspeed = maxspeed;
if (this.maxspeed < 0)
this.maxspeed = 0;
};
acts.SetAcceleration = function (acc)
{
this.acc = acc;
if (this.acc < 0)
this.acc = 0;
};
acts.SetDeceleration = function (dec)
{
this.dec = dec;
if (this.dec < 0)
this.dec = 0;
};
acts.SetJumpStrength = function (js)
{
this.jumpStrength = js;
if (this.jumpStrength < 0)
this.jumpStrength = 0;
};
acts.SetGravity = function (grav)
{
if (grav === this.g)
return;		// no change
this.g = grav;
this.updateGravity();
this.lastFloorObject = null;
};
acts.SetMaxFallSpeed = function (mfs)
{
this.maxFall = mfs;
if (this.maxFall < 0)
this.maxFall = 0;
};
acts.SimulateControl = function (ctrl)
{
switch (ctrl) {
case 0:		this.simleft = true;	break;
case 1:		this.simright = true;	break;
case 2:		this.simjump = true;	break;
}
};
acts.SetVectorX = function (vx)
{
this.dx = vx;
};
acts.SetVectorY = function (vy)
{
this.dy = vy;
};
acts.SetGravityAngle = function (a)
{
a = cr.to_radians(a);
a = cr.clamp_angle(a);
if (this.ga === a)
return;		// no change
this.ga = a;
this.updateGravity();
this.lastFloorObject = null;
};
acts.SetEnabled = function (en)
{
this.enabled = (en === 1);
};
behaviorProto.exps = {};
var exps = behaviorProto.exps;
exps.Speed = function (ret)
{
ret.set_float(Math.sqrt(this.dx * this.dx + this.dy * this.dy));
};
exps.MaxSpeed = function (ret)
{
ret.set_float(this.maxspeed);
};
exps.Acceleration = function (ret)
{
ret.set_float(this.acc);
};
exps.Deceleration = function (ret)
{
ret.set_float(this.dec);
};
exps.JumpStrength = function (ret)
{
ret.set_float(this.jumpStrength);
};
exps.Gravity = function (ret)
{
ret.set_float(this.g);
};
exps.MaxFallSpeed = function (ret)
{
ret.set_float(this.maxFall);
};
exps.MovingAngle = function (ret)
{
ret.set_float(cr.to_degrees(Math.atan2(this.dy, this.dx)));
};
exps.VectorX = function (ret)
{
ret.set_float(this.dx);
};
exps.VectorY = function (ret)
{
ret.set_float(this.dy);
};
}());
;
;
cr.behaviors.scrollto = function(runtime)
{
this.runtime = runtime;
this.shakeMag = 0;
this.shakeStart = 0;
this.shakeEnd = 0;
this.shakeMode = 0;
};
(function ()
{
var behaviorProto = cr.behaviors.scrollto.prototype;
behaviorProto.Type = function(behavior, objtype)
{
this.behavior = behavior;
this.objtype = objtype;
this.runtime = behavior.runtime;
};
var behtypeProto = behaviorProto.Type.prototype;
behtypeProto.onCreate = function()
{
};
behaviorProto.Instance = function(type, inst)
{
this.type = type;
this.behavior = type.behavior;
this.inst = inst;				// associated object instance to modify
this.runtime = type.runtime;
};
var behinstProto = behaviorProto.Instance.prototype;
behinstProto.onCreate = function()
{
};
behinstProto.tick = function ()
{
var all = this.behavior.my_instances.values();
var sumx = 0, sumy = 0;
var i, len;
for (i = 0, len = all.length; i < len; i++)
{
sumx += all[i].x;
sumy += all[i].y;
}
var layout = this.inst.layer.layout;
var now = this.runtime.kahanTime.sum;
var offx = 0, offy = 0;
if (now >= this.behavior.shakeStart && now < this.behavior.shakeEnd)
{
var mag = this.behavior.shakeMag * Math.min(this.runtime.timescale, 1);
if (this.behavior.shakeMode === 0)
mag *= 1 - (now - this.behavior.shakeStart) / (this.behavior.shakeEnd - this.behavior.shakeStart);
var a = Math.random() * Math.PI * 2;
var d = Math.random() * mag;
offx = Math.cos(a) * d;
offy = Math.sin(a) * d;
}
layout.scrollToX(sumx / all.length + offx);
layout.scrollToY(sumy / all.length + offy);
};
behaviorProto.acts = {};
var acts = behaviorProto.acts;
acts.Shake = function (mag, dur, mode)
{
this.behavior.shakeMag = mag;
this.behavior.shakeStart = this.runtime.kahanTime.sum;
this.behavior.shakeEnd = this.behavior.shakeStart + dur;
this.behavior.shakeMode = mode;
};
}());
;
;
cr.behaviors.solid = function(runtime)
{
this.runtime = runtime;
};
(function ()
{
var behaviorProto = cr.behaviors.solid.prototype;
behaviorProto.Type = function(behavior, objtype)
{
this.behavior = behavior;
this.objtype = objtype;
this.runtime = behavior.runtime;
};
var behtypeProto = behaviorProto.Type.prototype;
behtypeProto.onCreate = function()
{
};
behaviorProto.Instance = function(type, inst)
{
this.type = type;
this.behavior = type.behavior;
this.inst = inst;				// associated object instance to modify
this.runtime = type.runtime;
this.inst.extra.solidEnabled = true;
};
var behinstProto = behaviorProto.Instance.prototype;
behinstProto.onCreate = function()
{
};
behinstProto.tick = function ()
{
};
behaviorProto.acts = {};
var acts = behaviorProto.acts;
acts.SetEnabled = function (e)
{
this.inst.extra.solidEnabled = !!e;
};
}());
;
;
cr.behaviors.wrap = function(runtime)
{
this.runtime = runtime;
};
(function ()
{
var behaviorProto = cr.behaviors.wrap.prototype;
behaviorProto.Type = function(behavior, objtype)
{
this.behavior = behavior;
this.objtype = objtype;
this.runtime = behavior.runtime;
};
var behtypeProto = behaviorProto.Type.prototype;
behtypeProto.onCreate = function()
{
};
behaviorProto.Instance = function(type, inst)
{
this.type = type;
this.behavior = type.behavior;
this.inst = inst;				// associated object instance to modify
this.runtime = type.runtime;
};
var behinstProto = behaviorProto.Instance.prototype;
behinstProto.onCreate = function()
{
};
behinstProto.tick = function ()
{
var inst = this.inst;
inst.update_bbox();
var bbox = inst.bbox;
var layout = inst.layer.layout;
if (bbox.right < 0)
{
inst.x = layout.width - inst.x - 1;
inst.set_bbox_changed();
}
else if (bbox.left > layout.width)
{
inst.x = layout.width - inst.x + 1;
inst.set_bbox_changed();
}
else if (bbox.bottom < 0)
{
inst.y = layout.height - inst.y - 1;
inst.set_bbox_changed();
}
else if (bbox.top > layout.height)
{
inst.y = layout.height - inst.y + 1;
inst.set_bbox_changed();
}
};
}());
cr.getProjectModel = function() { return [
null,
null,
[
[
cr.plugins_.Audio,
true,
false,
false,
false,
false,
false,
false
]
,	[
cr.plugins_.Text,
false,
true,
true,
true,
false,
true,
true
]
,	[
cr.plugins_.Keyboard,
true,
false,
false,
false,
false,
false,
false
]
,	[
cr.plugins_.Sprite,
false,
true,
true,
true,
true,
true,
true
]
],
[
[
"t0",
cr.plugins_.Sprite,
null,
[
[
"Default",
5,
false,
1,
0,
false,
[
["images/background-default-000.png", 408064, 1, 0.5, 0.500949,[["Imagepoint 1", 0.244764, 0.0702087]],[]]
]
]
],
[
],
false
]
,	[
"t1",
cr.plugins_.Sprite,
null,
[
[
"Default",
5,
false,
1,
0,
false,
[
["images/lapin-default-000.png", 19700, 1, 0.5, 0.5,[],[-0.09375,-0.229167,0,-0.379167,0.41875,-0.445833,0.4,0,0.259375,0.472917,0,0.495833,-0.0375,0.191667,-0.409375,0.097917]]
]
]
],
[
],
false
]
,	[
"t2",
cr.plugins_.Sprite,
null,
[
[
"Default",
5,
false,
1,
0,
false,
[
["images/héro-default-000.png", 83118, 1, 0.5, 0.5,[],[0.217778,0,0.193333,0.091716,0,0.402367,-0.16,0.047337,-0.146667,0,-0.128889,-0.00591701,0,-0.428994,0.217778,-0.12426]],
["images/héro-default-001.png", 83352, 1, 0.5, 0.5,[],[-0.217778,-0.12426,0,-0.428994,0.128889,-0.00591701,0.146667,0,0.16,0.047337,0,0.402367,-0.193333,0.091716,-0.217778,0]]
]
]
],
[
[
"Platform",
cr.behaviors.Platform
]
,		[
"ScrollTo",
cr.behaviors.scrollto
]
],
false
]
,	[
"t3",
cr.plugins_.Sprite,
null,
[
[
"Default",
5,
false,
1,
0,
false,
[
["images/attaque-default-000.png", 24582, 1, 0.5, 0.5,[],[-0.375,-0.361446,0.077055,-0.162651,0.369863,0,0.114726,0.144578,-0.032534,0.240964,-0.363014,0.379518,-0.373288,0]]
]
]
],
[
[
"Bullet",
cr.behaviors.Bullet
]
,		[
"Wrap",
cr.behaviors.wrap
]
],
false
]
,	[
"t4",
cr.plugins_.Text,
null,
null,
[
[
"Fade",
cr.behaviors.Fade
]
,		[
"Solid",
cr.behaviors.solid
]
,		[
"ScrollTo",
cr.behaviors.scrollto
]
],
false
]
,	[
"t5",
cr.plugins_.Sprite,
null,
[
[
"Default",
5,
false,
1,
0,
false,
[
["images/bloc-default-000.png", 23691, 1, 0.5, 0.5,[],[-0.481164,-0.328313,0.467466,-0.331325,0.17637,0.054217,0.00856203,0.322289,-0.183219,0.057229]]
]
]
],
[
[
"Solid",
cr.behaviors.solid
]
],
false
]
,	[
"t6",
cr.plugins_.Sprite,
null,
[
[
"Default",
5,
false,
1,
0,
false,
[
["images/menotte-default-000.png", 66652, 1, 0.5, 0.5,[],[-0.24,-0.24,0,-0.083333,0.396667,-0.396667,0.153333,0,0.273333,0.273333,0,0.48,-0.33,0.33,-0.386667,0]]
]
]
],
[
],
false
]
,	[
"t7",
cr.plugins_.Text,
null,
null,
[
],
false
]
,	[
"t8",
cr.plugins_.Sprite,
null,
[
[
"Default",
5,
false,
1,
0,
false,
[
["images/clé-default-000.png", 20284, 1, 0.5, 0.5,[],[0.108333,-0.388889,0.480952,-0.480676,0.415476,-0.181159,-0.339286,0.483092,-0.476191,0.475845]]
]
]
],
[
],
false
]
,	[
"t9",
cr.plugins_.Audio,
null,
null,
[
],
false
,[0]
]
,	[
"t10",
cr.plugins_.Sprite,
null,
[
[
"Default",
5,
false,
1,
0,
false,
[
["images/lapin2-default-000.png", 19700, 1, 0.5, 0.5,[],[-0.09375,-0.229167,0,-0.379167,0.41875,-0.445833,0.4,0,0.259375,0.472917,0,0.495833,-0.0375,0.191667,-0.409375,0.097917]]
]
]
],
[
[
"Fade",
cr.behaviors.Fade
]
],
false
]
,	[
"t11",
cr.plugins_.Keyboard,
null,
null,
[
],
false
,[]
]
,	[
"t12",
cr.plugins_.Text,
null,
null,
[
],
false
]
,	[
"t13",
cr.plugins_.Sprite,
null,
[
[
"Default",
5,
false,
1,
0,
false,
[
["images/attaque2-default-000.png", 24582, 1, 0.5, 0.5,[],[-0.381849,-0.361446,0.063356,-0.159639,0.369863,0,0.121575,0.156627,-0.008562,0.23494,-0.363014,0.379518,-0.373288,0]]
]
]
],
[
],
false
]
,	[
"t14",
cr.plugins_.Text,
null,
null,
[
],
false
]
],
[
[
"Layout 1",
1532,
701,
false,
"Event sheet 1",
[
[
"Background",
0,
false,
[255, 255, 255],
false,
1,
1,
1,
false,
1,
[
[
[765, 351, 0, 1532, 701, 0, 0, 1, 0.5, 0.500949],
0,
[
],
[
],
[
0,
0,
0
]
]
]
]
,		[
"Main",
1,
false,
[255, 255, 255],
true,
1,
1,
1,
false,
1,
[
[
[1339, 545, 0, 88, 144, 0, 0, 1, 0.5, 0.5],
1,
[
],
[
],
[
0,
0,
0
]
]
,			[
[199, 669, 0, 67, 84, 0, 1.5708, 1, 0.5, 0.5],
3,
[
],
[
[
400,
0,
0,
0,
1
],
[
]
],
[
0,
0,
0
]
]
,			[
[50, 675, 0, 97, 68, 0, 0, 1, 0.5, 0.5],
5,
[
],
[
[
]
],
[
0,
0,
0
]
]
,			[
[57, 612, 0, 82, 75, 0, 0, 1, 0.5, 0.5],
2,
[
],
[
[
330,
1500,
1500,
650,
1500,
1000,
0
],
[
]
],
[
0,
0,
0
]
]
,			[
[1336, 584, 0, 115, 75, 0, -2.40888, 1, 0.5, 0.5],
6,
[
0
],
[
],
[
0,
0,
0
]
]
,			[
[1364, 512, 0, 159, 40, 0, 0, 1, 0, 0],
7,
[
0
],
[
],
[
"Détache moi !",
0,
"18pt Arial",
"rgb(255,0,0)",
0
]
]
,			[
[67, 148, 0, 97, 68, 0, 0, 1, 0.5, 0.5],
5,
[
],
[
[
]
],
[
0,
0,
0
]
]
,			[
[70, 96, 0, 49, 50, 0, 0, 1, 0.5, 0.5],
8,
[
],
[
],
[
0,
0,
0
]
]
,			[
[317, 617, 0, 97, 68, 0, 0, 1, 0.5, 0.5],
5,
[
],
[
[
]
],
[
0,
0,
0
]
]
,			[
[1425, 495, 0, 97, 68, 0, 0, 1, 0.5, 0.5],
5,
[
],
[
[
]
],
[
0,
0,
0
]
]
,			[
[1312, 638, 0, 97, 68, 0, 0, 1, 0.5, 0.5],
5,
[
],
[
[
]
],
[
0,
0,
0
]
]
,			[
[961, 673, 0, 97, 68, 0, 0, 1, 0.5, 0.5],
5,
[
],
[
[
]
],
[
0,
0,
0
]
]
,			[
[276, 158, 0, 97, 68, 0, 0, 1, 0.5, 0.5],
5,
[
],
[
[
]
],
[
0,
0,
0
]
]
,			[
[629, 614, 0, 97, 68, 0, 0, 1, 0.5, 0.5],
5,
[
],
[
[
]
],
[
0,
0,
0
]
]
,			[
[457, 628, 0, 67, 84, 0, 1.5708, 1, 0.5, 0.5],
3,
[
],
[
[
400,
0,
0,
0,
1
],
[
]
],
[
0,
0,
0
]
]
,			[
[1055, 533, 0, 97, 68, 0, 0, 1, 0.5, 0.5],
5,
[
],
[
[
]
],
[
0,
0,
0
]
]
,			[
[1232, 244, 0, 97, 68, 0, -0.0116947, 1, 0.5, 0.5],
5,
[
],
[
[
]
],
[
0,
0,
0
]
]
,			[
[1004, 236, 0, 97, 68, 0, 0, 1, 0.5, 0.5],
5,
[
],
[
[
]
],
[
0,
0,
0
]
]
,			[
[1317, 357, 0, 97, 68, 0, 0, 1, 0.5, 0.5],
5,
[
],
[
[
]
],
[
0,
0,
0
]
]
,			[
[1161, 663, 0, 67, 84, 0, 1.5708, 1, 0.5, 0.5],
3,
[
],
[
[
400,
0,
0,
0,
1
],
[
]
],
[
0,
0,
0
]
]
,			[
[645, 219, 0, 97, 68, 0, 0, 1, 0.5, 0.5],
5,
[
],
[
[
]
],
[
0,
0,
0
]
]
,			[
[379, 276, 0, 97, 68, 0, 0, 1, 0.5, 0.5],
5,
[
],
[
[
]
],
[
0,
0,
0
]
]
,			[
[1381, 528, 0, 200, 59, 0, 0, 1, 0, 0],
12,
[
0
],
[
],
[
"MERCI !!!",
1,
"18pt Arial",
"rgb(255,0,0)",
0
]
]
,			[
[810, 163, 0, 97, 68, 0, 0, 1, 0.5, 0.5],
5,
[
],
[
[
]
],
[
0,
0,
0
]
]
,			[
[1120, 163, 0, 144, 179, 0, -1.56625, 1, 0.5, 0.5],
13,
[
],
[
],
[
0,
0,
0
]
]
]
]
,		[
"Intro",
2,
true,
[255, 255, 255],
true,
1,
1,
1,
false,
1,
[
[
[78, 365, 0, 558, 138, 0, 0, 1, 0, 0],
4,
[
],
[
[
0,
4,
3,
1
],
[
],
[
]
],
[
"Sauve le laPont rose ! Joue avec les flèches et Espace pour sauter",
0,
"bold 20pt Segoe Script",
"rgb(153,0,0)",
0
]
]
,			[
[275, 583, 0, 121, 183, 0, 0, 1, 0.5, 0.5],
10,
[
],
[
[
0,
4,
3,
1
]
],
[
0,
0,
0
]
]
]
]
],
[
]
]
,	[
"Layout 2",
1280,
1024,
false,
"Event sheet 2",
[
[
"Layer 0",
0,
true,
[255, 255, 255],
false,
1,
1,
1,
false,
1,
[
[
[138, 151, 0, 436, 234, 0, 0, 1, 0, 0],
14,
[
],
[
],
[
"Félicitations ! Le lapont rose t'est reconnaissant !!",
0,
"20pt Segoe Script",
"rgb(153,0,0)",
0
]
]
]
]
],
[
]
]
],
[
[
"Event sheet 1",
[
[
0,
null,
[
[
2,
cr.plugins_.Sprite.prototype.cnds.CompareY,
null,
false,
false,
false,
false
,[
[
8,
5
]
,				[
0,
[
0,
705
]
]
]
]
],
[
[
2,
cr.plugins_.Sprite.prototype.acts.SetPos,
null
,[
[
0,
[
0,
61
]
]
,				[
0,
[
0,
612
]
]
]
]
]
]
,		[
0,
null,
[
[
3,
cr.plugins_.Sprite.prototype.cnds.IsOverlapping,
null,
false,
false,
false,
true
,[
[
4,
2
]
]
]
],
[
[
2,
cr.plugins_.Sprite.prototype.acts.SetPos,
null
,[
[
0,
[
0,
61
]
]
,				[
0,
[
0,
612
]
]
]
]
,			[
8,
cr.plugins_.Sprite.prototype.acts.SetVisible,
null
,[
[
3,
1
]
]
]
,			[
6,
cr.plugins_.Sprite.prototype.acts.SetInstanceVar,
null
,[
[
10,
0
]
,				[
7,
[
0,
0
]
]
]
]
]
]
,		[
0,
null,
[
[
11,
cr.plugins_.Keyboard.prototype.cnds.OnKey,
null,
true,
false,
false,
false
,[
[
9,
32
]
]
]
],
[
[
2,
cr.behaviors.Platform.prototype.acts.SimulateControl,
"Platform"
,[
[
3,
2
]
]
]
]
]
,		[
0,
null,
[
[
-1,
cr.system_object.prototype.cnds.CompareTime,
null,
false,
false,
false,
false
,[
[
8,
0
]
,				[
0,
[
0,
7
]
]
]
]
],
[
[
-1,
cr.system_object.prototype.acts.SetLayerVisible,
null
,[
[
5,
[
0,
1
]
]
,				[
3,
1
]
]
]
,			[
-1,
cr.system_object.prototype.acts.SetLayerVisible,
null
,[
[
5,
[
0,
0
]
]
,				[
3,
1
]
]
]
]
]
,		[
0,
null,
[
[
11,
cr.plugins_.Keyboard.prototype.cnds.IsKeyDown,
null,
false,
false,
false,
false
,[
[
9,
39
]
]
]
],
[
[
2,
cr.behaviors.Platform.prototype.acts.SimulateControl,
"Platform"
,[
[
3,
1
]
]
]
]
]
,		[
0,
null,
[
[
11,
cr.plugins_.Keyboard.prototype.cnds.IsKeyDown,
null,
false,
false,
false,
false
,[
[
9,
37
]
]
]
],
[
[
2,
cr.behaviors.Platform.prototype.acts.SimulateControl,
"Platform"
,[
[
3,
0
]
]
]
]
]
,		[
0,
null,
[
[
11,
cr.plugins_.Keyboard.prototype.cnds.OnKey,
null,
true,
false,
false,
false
,[
[
9,
39
]
]
]
],
[
[
2,
cr.plugins_.Sprite.prototype.acts.SetAnimFrame,
null
,[
[
0,
[
0,
0
]
]
]
]
]
]
,		[
0,
null,
[
[
11,
cr.plugins_.Keyboard.prototype.cnds.OnKey,
null,
true,
false,
false,
false
,[
[
9,
37
]
]
]
],
[
[
2,
cr.plugins_.Sprite.prototype.acts.SetAnimFrame,
null
,[
[
0,
[
0,
1
]
]
]
]
]
]
,		[
0,
null,
[
[
8,
cr.plugins_.Sprite.prototype.cnds.IsOverlapping,
null,
false,
false,
false,
true
,[
[
4,
2
]
]
]
],
[
[
8,
cr.plugins_.Sprite.prototype.acts.SetVisible,
null
,[
[
3,
0
]
]
]
,			[
6,
cr.plugins_.Sprite.prototype.acts.SetInstanceVar,
null
,[
[
10,
0
]
,				[
7,
[
0,
1
]
]
]
]
,			[
9,
cr.plugins_.Audio.prototype.acts.Preload,
null
,[
[
2,
["victoire",true]
]
]
]
]
]
,		[
0,
null,
[
[
2,
cr.plugins_.Sprite.prototype.cnds.OnCollision,
null,
false,
false,
false,
true
,[
[
4,
1
]
]
]
,			[
6,
cr.plugins_.Sprite.prototype.cnds.CompareInstanceVar,
null,
false,
false,
false,
false
,[
[
10,
0
]
,				[
8,
0
]
,				[
7,
[
0,
1
]
]
]
]
],
[
[
7,
cr.plugins_.Text.prototype.acts.Destroy,
null
]
,			[
6,
cr.plugins_.Sprite.prototype.acts.Destroy,
null
]
,			[
12,
cr.plugins_.Text.prototype.acts.SetVisible,
null
,[
[
3,
1
]
]
]
,			[
9,
cr.plugins_.Audio.prototype.acts.Stop,
null
,[
[
1,
[
2,
"Zik"
]
]
]
]
,			[
9,
cr.plugins_.Audio.prototype.acts.Play,
null
,[
[
2,
["victoire",true]
]
,				[
1,
[
2,
""
]
]
]
]
,			[
-1,
cr.system_object.prototype.acts.Wait,
null
,[
[
0,
[
0,
3
]
]
]
]
,			[
-1,
cr.system_object.prototype.acts.GoToLayout,
null
,[
[
6,
"Layout 2"
]
]
]
]
]
,		[
0,
null,
[
[
-1,
cr.system_object.prototype.cnds.OnLayoutStart,
null,
true,
false,
false,
false
]
],
[
[
9,
cr.plugins_.Audio.prototype.acts.Preload,
null
,[
[
2,
["best part ever2",true]
]
]
]
,			[
-1,
cr.system_object.prototype.acts.Wait,
null
,[
[
0,
[
0,
5
]
]
]
]
,			[
9,
cr.plugins_.Audio.prototype.acts.Play,
null
,[
[
2,
["best part ever2",true]
]
,				[
1,
[
2,
"Zik"
]
]
]
]
]
]
,		[
0,
null,
[
[
13,
cr.plugins_.Sprite.prototype.cnds.OnCollision,
null,
false,
false,
false,
true
,[
[
4,
2
]
]
]
],
[
[
2,
cr.plugins_.Sprite.prototype.acts.SetPos,
null
,[
[
0,
[
0,
61
]
]
,				[
0,
[
0,
612
]
]
]
]
,			[
8,
cr.plugins_.Sprite.prototype.acts.SetVisible,
null
,[
[
3,
1
]
]
]
,			[
6,
cr.plugins_.Sprite.prototype.acts.SetInstanceVar,
null
,[
[
10,
0
]
,				[
7,
[
0,
0
]
]
]
]
]
]
]
]
,	[
"Event sheet 2",
[
]
]
],
"media/",
false,
640,
480,
false,
false,
true
];};

window["cr"] = cr;
window["cr"]["createRuntime"] = cr.createRuntime;
